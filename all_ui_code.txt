
---- app/components/chat/ModelSelector.tsx ----
// app/components/chat/ModelSelector.tsx
import { ChevronDownIcon, FileDownIcon } from 'lucide-react';
import type { AIModelConfig } from '~/lib/ai-models'; // Adjust path as needed

interface ModelSelectorProps {
  models: AIModelConfig[];
  selectedModel: AIModelConfig;
  onModelChange: (model: AIModelConfig) => void;
  disabled?: boolean;
  className?: string; // Allow passing custom classes
}

export function ModelSelector({
  models,
  selectedModel,
  onModelChange,
  disabled,
  className,
}: ModelSelectorProps) {
  const handleChange = (event: React.ChangeEvent<HTMLSelectElement>) => {
    const selected = models.find(
      (m) =>
        m.model === event.target.value &&
        m.provider ===
          event.target.options[event.target.selectedIndex].dataset.provider
    );
    if (selected) {
      onModelChange(selected);
    }
  };

  return (
    <div className={`inline-block relative ${className || ''}`}>
      <select
        value={selectedModel.model} // Ensure value matches one of the option values
        onChange={handleChange}
        disabled={disabled}
        className="appearance-none text-xs font-medium bg-background hover:bg-muted border border-input rounded-md px-2.5 py-1.5 pr-7 focus:ring-1 focus:ring-primary focus:outline-none focus:border-primary disabled:opacity-70 disabled:cursor-not-allowed"
      >
        {models.map((model) => (
          <option
            key={`${model.provider}-${model.model}`}
            value={model.model}
            data-provider={model.provider}
          >
            {model.displayName}
          </option>
        ))}
      </select>
      <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-1.5 text-muted-foreground">
        <FileDownIcon className="h-3.5 w-3.5" />
      </div>
    </div>
  );
}
---- app/components/chat/ChatInputBar.tsx ----
// app/components/chat/ChatInputBar.tsx
import React, { useRef, useEffect } from 'react';
import { ArrowUp, Paperclip, Settings2 } from 'lucide-react';
import type { AIModelConfig } from '~/lib/ai-models';
import { ModelSelector } from './ModelSelector'; // Import ModelSelector

const isProbablyMobile = () => typeof window !== 'undefined' && window.innerWidth < 768;

interface ChatInputBarProps {
  input: string;
  onInputChange: (event: React.ChangeEvent<HTMLTextAreaElement>) => void;
  onSubmit: (e: React.FormEvent<HTMLFormElement>) => void;
  isLoading: boolean;
  availableModels: AIModelConfig[];
  selectedModel: AIModelConfig;
  onModelChange: (model: AIModelConfig) => void;
}

const MIN_TEXTAREA_HEIGHT_REM = 1.625;
const TEXTAREA_PADDING_Y_PX = 20; 
const MAX_TEXTAREA_HEIGHT_PX = 144; 

export function ChatInputBar({
  input,
  onInputChange,
  onSubmit,
  isLoading,
  availableModels,
  selectedModel,
  onModelChange,
}: ChatInputBarProps) {
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  useEffect(() => {
    const textarea = textareaRef.current;
    if (textarea) {
      textarea.style.height = 'auto'; 
      const scrollHeight = textarea.scrollHeight;
      const newHeight = Math.min(scrollHeight, MAX_TEXTAREA_HEIGHT_PX);
      textarea.style.height = `${newHeight}px`;
    }
  }, [input]);

  const handleTextareaKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    const mobile = isProbablyMobile();
    if (e.key === 'Enter' && (e.shiftKey || e.ctrlKey)) return; 
    if (mobile && e.key === 'Enter') return; 
    if (e.key === 'Enter' && !mobile) {
      e.preventDefault();
      if (!isLoading && (input || '').trim()) {
        const form = e.currentTarget.form;
        if (form) form.requestSubmit();
      }
    }
  };

  const isSendDisabled = isLoading || !(input || '').trim();

  return (
    <div className="w-full flex-shrink-0">
      <form
        onSubmit={onSubmit}
        className="relative mx-auto flex w-full flex-col rounded-xl bg-card p-2.5 shadow-xl ring-1 ring-border sm:p-3"
      >
        <textarea
          ref={textareaRef}
          value={input || ''}
          onChange={onInputChange}
          onKeyDown={handleTextareaKeyDown}
          placeholder={selectedModel ? `Ask ${selectedModel.displayName}...` : 'Select a model...'}
          rows={1}
          className="w-full resize-none overflow-y-auto rounded-lg border-none bg-transparent px-3 py-2.5 text-base text-foreground outline-none placeholder:text-muted-foreground focus:ring-0"
          style={{
            minHeight: `calc(${MIN_TEXTAREA_HEIGHT_REM}rem + ${TEXTAREA_PADDING_Y_PX}px)`,
            maxHeight: `${MAX_TEXTAREA_HEIGHT_PX}px`,
          }}
          disabled={isLoading}
          aria-label="Chat message input"
        />
        <div className="mt-2 flex items-center justify-between">
          <div className="flex items-center gap-1.5">
            <ModelSelector
              models={availableModels}
              selectedModel={selectedModel}
              onModelChange={onModelChange}
              disabled={isLoading || !availableModels || availableModels.length === 0}
            />
          </div>
          <div className="flex items-center gap-1 sm:gap-1.5">
            <button type="button" className="p-1.5 text-muted-foreground hover:text-foreground hover:bg-muted sm:p-2 rounded-md disabled:opacity-50" disabled={true} title="Attach file (soon)">
              <Paperclip size={18} strokeWidth={2} />
            </button>
            <button type="button" className="p-1.5 text-muted-foreground hover:text-foreground hover:bg-muted sm:p-2 rounded-md disabled:opacity-50" disabled={true} title="Model options (soon)">
              <Settings2 size={18} strokeWidth={2} />
            </button>
            <button type="submit" className="flex items-center justify-center rounded-lg bg-primary px-3 py-2 text-primary-foreground hover:bg-primary/90 disabled:opacity-50" disabled={isSendDisabled} title="Send message">
              <ArrowUp size={20} strokeWidth={2.25} />
            </button>
          </div>
        </div>
      </form>
    </div>
  );
}
---- app/components/chat/MessageList.tsx ----
// app/components/MessageList.tsx
import type { RefObject } from 'react';
import type { Message } from './MessageItem'; // Assuming MessageItem exports Message type
import { MessageItem } from './MessageItem';

interface MessageListProps {
  messages: Message[];
  isLoading: boolean; // This prop is now only for isInitialHistoryLoading visual cues if any, or can be removed if not used elsewhere
  isInitialHistoryLoading?: boolean;
  scrollEndRef: RefObject<HTMLDivElement>;
}

export function MessageList({
  messages,
  // isLoading, // This prop is no longer used for the assistant typing indicator here
  isInitialHistoryLoading = false, // Keep if used for other purposes
  scrollEndRef,
}: MessageListProps) {
  return (
    <div className="p-4 space-y-4"> {/* Ensure this padding is desired, or remove if MessageItem handles it */}
      {messages.map((msg) => (
        <MessageItem key={msg.id} message={msg} />
      ))}
      
      <div ref={scrollEndRef} style={{ height: '1px' }} />
    </div>
  );
}
---- app/components/chat/InitialPrompts.tsx ----
interface InitialPromptsProps {
  onPromptSelect: (prompt: string) => void;
}

const suggestions = [
  "What are the advantages of using Next.js?",
  "Write code to demonstrate Dijkstra's algorithm",
  "Help me write an essay about Silicon Valley",
  "What is the weather in San Francisco?",
];

export function InitialPrompts({ onPromptSelect }: InitialPromptsProps) {
  return (
    <div className="flex flex-col items-center justify-center h-full p-4">
      <h1 className="text-3xl font-semibold mb-2">Hello there!</h1>
      <p className="text-muted-foreground mb-8">How can I help you today?</p>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4 w-full max-w-xl">
        {suggestions.map((prompt) => (
          <button
            key={prompt}
            onClick={() => onPromptSelect(prompt)}
            className="p-4 border rounded-lg hover:bg-muted text-left text-sm" // Basic styling
          >
            <p className="font-medium">{prompt.split(' ').slice(0, 5).join(' ')}{prompt.split(' ').length > 5 ? '...' : ''}</p>
            <p className="text-xs text-muted-foreground mt-1">
              {prompt.startsWith("Write code") ? "Code generation" : 
               prompt.startsWith("Help me write") ? "Writing assistance" : 
               "General query"}
            </p>
          </button>
        ))}
      </div>
    </div>
  );
}
---- app/components/chat/MessageItem.tsx ----
// app/components/chat/MessageItem.tsx
import React from 'react';
import { Markdown } from '../Markdown';
import { Copy, Loader2 } from 'lucide-react'; // Import Loader2
import { SiBoat } from 'react-icons/si';

// Message interface (ensure isLoading is here from previous step)
export interface Message {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  isLoading?: boolean;
  timestamp?: number; // Keep if you added this previously
}

interface MessageItemProps {
  message: Message;
}

export function MessageItem({ message }: MessageItemProps) {
  const isUser = message.role === 'user';
  const messageRef = React.useRef<HTMLDivElement>(null);

  const handleCopy = () => {
    if (messageRef.current) {
      const textToCopy = messageRef.current.innerText;
      navigator.clipboard.writeText(textToCopy);
      // Add toast notification here if needed
    }
  };

  return (
    <div className={`flex ${isUser ? 'justify-end' : 'justify-start'} mb-4`}>
      <div className={`max-w-[100%] md:max-w-[100%] flex flex-col ${isUser ? 'items-end' : 'items-start'}`}>
        {/* Header - only for assistant */}
        {!isUser && (
          <div className="flex items-center mb-1 px-3">
            <div className="w-9 h-9 rounded-full bg-white flex items-center justify-center mr-2">
              <SiBoat color="#7c3aed" className="text-2xl" />
            </div>
            <span className="font-semibold text-sm text-violet-600">AI</span>
            {/* START: Updated loading indicator */}
            {message.isLoading && (
              <div className="ml-2 flex items-center justify-center">
                <Loader2 className="h-4 w-4 animate-spin text-muted-foreground" />
              </div>
            )}
            {/* END: Updated loading indicator */}
          </div>
        )}

        {/* Message content */}
        <div
          ref={messageRef}
          className={
            isUser
              ? `px-3 py-2 rounded-lg shadow bg-primary text-primary-foreground
                  prose prose-sm md:prose-base dark:prose-invert break-words prose-primary-invert`
              : `px-3 py-2
                  prose prose-sm md:prose-base dark:prose-invert break-words text-foreground`
          }
        >
          {(message.content || !message.isLoading) && <Markdown>{message.content}</Markdown>}
        </div>

        {/* Action buttons row - properly aligned with message width */}
        <div
          className={`flex mt-1 space-x-2 ${isUser ? 'justify-end' : 'justify-start'}`}
          style={{ width: 'fit-content' }}
        >
          <button
            onClick={handleCopy}
            className="text-muted-foreground hover:text-foreground transition-colors p-1 rounded hover:bg-muted"
            aria-label="Copy message"
          >
            <Copy className="w-4 h-4" />
          </button>
        </div>
      </div>
    </div>
  );
}
---- app/components/chat/streaming-chat-context.tsx ----
// app/components/chat/streaming-chat-context.tsx
import React, { createContext, useContext, useState, useRef, useCallback, useEffect } from 'react';
import type { Message } from '~/components/chat/MessageItem';
import type { AIModelConfig } from '~/lib/ai-models';
import { API_STREAM_URL, defaultSystemPrompt } from '~/lib/ai-models';

interface StreamData {
  chatId?: string; // Backend might still send this, but we won't use it for session ID determination
  content?: string;
  type?: 'metadata' | 'content_start' | 'stream_end' | 'error' | 'usage_summary' | 'chat_id_update';
  error?: { message: string };
}

export interface StreamingChatContextType {
  messages: Message[];
  isStreaming: boolean;
  streamError: string | null;
  activeStreamChatId: string | null; // ChatId of the stream being processed
  currentUIFocusChatId: string | null; // ChatId the UI is currently focused on
  startStream: (
    prompt: string,
    modelConfig: AIModelConfig,
    chatIdToStream: string, // Authoritative Chat ID for this stream
  ) => Promise<void>; // No longer returns a chatId, as frontend dictates it
  abortStream: (reason?: string) => void;
  setMessagesForContext: (messages: Message[], uiFocusedChatId: string | null) => void;
  clearStreamState: () => void;
}

const StreamingChatContext = createContext<StreamingChatContextType | undefined>(undefined);

export const StreamingChatProvider = ({ children }: { children: React.ReactNode }) => {
  const [messages, setMessages] = useState<Message[]>([]);
  const [isStreaming, setIsStreaming] = useState(false);
  const [streamError, setStreamError] = useState<string | null>(null);
  const [activeStreamChatId, setActiveStreamChatId] = useState<string | null>(null);
  const [currentUIFocusChatId, setCurrentUIFocusChatId] = useState<string | null>(null);

  const abortControllerRef = useRef<AbortController | null>(null);
  const currentAssistantMessageIdRef = useRef<string | null>(null);

  const setMessagesForContext = useCallback((newMessages: Message[], uiFocusedChatId: string | null) => {
    console.log(`Context: setMessagesForContext called. New messages count: ${newMessages.length}, UI Focus: ${uiFocusedChatId}, Current Active Stream: ${activeStreamChatId}`);
    setMessages(newMessages);
    setCurrentUIFocusChatId(uiFocusedChatId);

    if (activeStreamChatId && uiFocusedChatId !== activeStreamChatId && isStreaming) {
      console.log(`Context: UI focus changed to ${uiFocusedChatId} from active stream ${activeStreamChatId}. Aborting stream.`);
      abortControllerRef.current?.abort("UI context changed away from active stream");
      // Reset streaming states, message updates handled by abortStream/finally in startStream
      setIsStreaming(false);
      // setActiveStreamChatId(null); // Keep activeStreamChatId until a new stream starts or state is cleared
      if (currentAssistantMessageIdRef.current) {
        setMessages(prev => prev.map(msg => msg.id === currentAssistantMessageIdRef.current && msg.isLoading ? { ...msg, isLoading: false, content: msg.content || "[Stream context changed]" } : msg));
        currentAssistantMessageIdRef.current = null;
      }
    }
  }, [activeStreamChatId, isStreaming]);

  const clearStreamState = useCallback(() => {
    console.log("Context: clearStreamState called.");
    if (isStreaming && abortControllerRef.current) {
      abortControllerRef.current.abort("Clearing stream state");
    }
    setMessages([]);
    setIsStreaming(false);
    setStreamError(null);
    setActiveStreamChatId(null);
    setCurrentUIFocusChatId(null);
    currentAssistantMessageIdRef.current = null;
    if (abortControllerRef.current) {
      abortControllerRef.current = null;
    }
  }, [isStreaming]);

  const abortStream = useCallback((reason: string = "User requested abort") => {
    if (abortControllerRef.current && !abortControllerRef.current.signal.aborted) {
      console.log(`Context: Aborting stream. Reason: ${reason}`);
      abortControllerRef.current.abort(reason);
    }
    // Ensure state is updated even if abort is called externally / multiple times
    if (isStreaming) {
      setIsStreaming(false);
      if (currentAssistantMessageIdRef.current) {
        setMessages(prev =>
          prev.map(msg =>
            msg.id === currentAssistantMessageIdRef.current && msg.isLoading
              ? { ...msg, isLoading: false, content: msg.content || `[Stream aborted: ${reason}]` }
              : msg
          )
        );
        currentAssistantMessageIdRef.current = null;
      }
    }
    // abortControllerRef.current = null; // Will be reset on next startStream
  }, [isStreaming]);

  const startStream = useCallback(
    async (
      prompt: string,
      modelConfig: AIModelConfig,
      chatIdToStream: string, // Authoritative Chat ID (frontend-generated for new)
    ): Promise<void> => {
      if (isStreaming && abortControllerRef.current && !abortControllerRef.current.signal.aborted) {
        console.warn("Context: Stream already in progress. Aborting previous to start new one.");
        abortControllerRef.current.abort("New stream started, superceded by new request.");
      }

      console.log(`Context: startStream called for chatId: ${chatIdToStream}`);
      setIsStreaming(true);
      setStreamError(null);
      setActiveStreamChatId(chatIdToStream); // This stream is for this ID

      // The user message should already be in `messages` via `setMessagesForContext`
      // We only add the assistant placeholder here.
      const assistantMsgId = crypto.randomUUID();
      currentAssistantMessageIdRef.current = assistantMsgId;
      const assistantPlaceholder: Message = { id: assistantMsgId, role: 'assistant', content: '', isLoading: true };

      setMessages(prevMessages => [...prevMessages, assistantPlaceholder]);

      abortControllerRef.current = new AbortController();

      try {
        const response = await fetch(API_STREAM_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'Accept': 'text/event-stream' },
          body: JSON.stringify({
            chatId: chatIdToStream, // Send the authoritative chatId
            message: prompt,
            provider: modelConfig.provider,
            model: modelConfig.model,
            systemPrompt: defaultSystemPrompt,
          }),
          signal: abortControllerRef.current.signal,
          credentials: 'include',
        });

        if (abortControllerRef.current.signal.aborted) {
          console.log("Context: Stream fetch aborted before response fully processed.");
          // Message update is handled in finally or if abortStream was called directly
          return;
        }

        if (!response.ok || !response.body) {
          const errorBody = await response.text().catch(() => "Failed to read error body");
          setStreamError(`API Error ${response.status}: ${errorBody}`);
          setMessages(prev => prev.map(m => m.id === assistantMsgId ? { ...m, isLoading: false, content: `API Error: ${response.status}` } : m));
          setIsStreaming(false);
          currentAssistantMessageIdRef.current = null;
          return;
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = "";

        while (true) {
          const { done, value } = await reader.read();
          if (abortControllerRef.current?.signal.aborted) {
            console.log("Context: Stream processing loop aborted by signal.");
            // Message update is handled by abortStream or finally block.  
            break;
          }
          if (done) {
            console.log("Context: Stream finished naturally.");
            break;
          }

          buffer += decoder.decode(value, { stream: true });
          let newlineIndex;
          while ((newlineIndex = buffer.indexOf('\n')) >= 0) {
            const line = buffer.slice(0, newlineIndex).trim();
            buffer = buffer.slice(newlineIndex + 1);

            if (line.startsWith("data: ")) {
              const jsonDataString = line.substring(5);
              if (jsonDataString && !abortControllerRef.current?.signal.aborted) {
                try {
                  const chunk: StreamData = JSON.parse(jsonDataString);

                  // ... your chunk handling logic ...  
                  if (chunk.type === 'chat_id_update' && chunk.chatId && chunk.chatId !== chatIdToStream) {
                    console.warn(`Context: Backend sent a chatId ${chunk.chatId} different from frontend's ${chatIdToStream}. Ignoring backend's for session ID.`);
                  }

                  if (chunk.content) {
                    setMessages(prev =>
                      prev.map(msg =>
                        msg.id === assistantMsgId
                          ? { ...msg, content: msg.content + chunk.content, isLoading: true }
                          : msg
                      )
                    );
                  }

                  if (chunk.type === 'stream_end' || chunk.type === 'usage_summary') {
                    // Stream ended from backend's perspective  
                    if (!abortControllerRef.current?.signal.aborted) { // Only if not already handled by an abort  
                      setMessages(prev => prev.map(msg => msg.id === assistantMsgId ? { ...msg, isLoading: false } : msg));
                      setIsStreaming(false);
                      currentAssistantMessageIdRef.current = null;
                    }
                  } else if (chunk.error) {
                    if (!abortControllerRef.current?.signal.aborted) {
                      setStreamError(chunk.error?.message || "Stream error from backend"); // <-- FIXED  
                      setMessages(prev => prev.map(m =>
                        m.id === assistantMsgId
                          ? { ...m, isLoading: false, content: `${m.content || ""}\n[Error: ${chunk.error?.message ?? "Unknown error"}]` }
                          : m
                      ));
                      setIsStreaming(false);
                      currentAssistantMessageIdRef.current = null;
                    }
                    break; // Break from while loop on backend error  
                  }

                  // Optional: break out of the while(line) if error type  
                  if (chunk.type === 'error' || chunk.error) break;

                } catch (e: any) {
                  if (!abortControllerRef.current?.signal.aborted) {
                    console.error("Context: Error parsing stream data JSON:", e, jsonDataString);
                    setStreamError(`Error parsing stream: ${e.message}`);
                    setMessages(prev => prev.map(m => m.id === assistantMsgId ? { ...m, isLoading: false, content: `${m.content || ""}\n[Error parsing stream data]` } : m));
                    setIsStreaming(false);
                    currentAssistantMessageIdRef.current = null;
                  }
                  break; // Break from while loop on parsing error  
                }
              }
            }
          }
        }

        if (!abortControllerRef.current?.signal.aborted && isStreaming) { // Stream ended naturally by `done` or outer break
          setIsStreaming(false);
          setMessages(prev => prev.map(msg => msg.id === assistantMsgId && msg.isLoading ? { ...msg, isLoading: false } : msg));
          currentAssistantMessageIdRef.current = null;
        }

      } catch (error: any) {
        if (error.name === 'AbortError' || abortControllerRef.current?.signal.aborted) {
          console.log(`Context: Stream operation was aborted. Message: ${error.message}`);
          if (isStreaming) setIsStreaming(false);
          setMessages(prev => prev.map(msg => msg.id === assistantMsgId && msg.isLoading ? { ...msg, isLoading: false, content: msg.content || `[Stream aborted]` } : msg));
        } else {
          console.error("Context: Send/Stream error:", error);
          setStreamError(error.message || "An unknown error occurred.");
          setMessages(prev =>
            prev.map(msg =>
              msg.id === assistantMsgId
                ? { ...msg, content: (msg.content || "") + `\n[Error: ${error.message}]`, isLoading: false }
                : msg
            )
          );
          if (isStreaming) setIsStreaming(false);
        }
        if (currentAssistantMessageIdRef.current === assistantMsgId) {
          currentAssistantMessageIdRef.current = null;
        }
      } finally {
        // If stream ended, but not due to abort, and we are still marked as streaming (e.g. loop break), ensure cleanup.
        // This is a safeguard.
        if (isStreaming && (!abortControllerRef.current || !abortControllerRef.current.signal.aborted)) {
          setIsStreaming(false);
          if (currentAssistantMessageIdRef.current === assistantMsgId) {
            setMessages(prev => prev.map(msg => msg.id === assistantMsgId && msg.isLoading ? { ...msg, isLoading: false } : msg));
            currentAssistantMessageIdRef.current = null;
          }
        }
        // The AbortController instance is specific to this call of startStream.
        // It's fine if abortControllerRef.current is overwritten by a subsequent call.
      }
    },
    [isStreaming, abortStream] // Removed currentUIFocusChatId, as chatIdToStream is authoritative
  );

  useEffect(() => {
    return () => {
      if (abortControllerRef.current && !abortControllerRef.current.signal.aborted) {
        console.log("StreamingChatProvider unmounting, aborting any active non-aborted stream.");
        abortControllerRef.current.abort("Provider unmounted");
      }
      abortControllerRef.current = null;
    };
  }, []);

  const contextValue: StreamingChatContextType = {
    messages,
    isStreaming,
    streamError,
    activeStreamChatId,
    currentUIFocusChatId,
    startStream,
    abortStream,
    setMessagesForContext,
    clearStreamState,
  };

  return <StreamingChatContext.Provider value={contextValue}>{children}</StreamingChatContext.Provider>;
};

export const useStreamingChat = (): StreamingChatContextType => {
  const context = useContext(StreamingChatContext);
  if (!context) {
    throw new Error('useStreamingChat must be used within a StreamingChatProvider');
  }
  return context;
};
---- app/components/chat/ChatPageLayout.tsx ----
// app/components/chat/ChatPageLayout.tsx
import { useState, useEffect, useCallback, useRef, useTransition as useReactTransitionHook } from 'react';
import { useNavigate, useLocation, useNavigation as useRemixNavigation, useParams } from '@remix-run/react';
import { v4 as uuidv4 } from 'uuid';
import type { Message } from './MessageItem';
import { MessageList } from './MessageList';
import { ChatInputBar } from './ChatInputBar';
import { InitialPrompts } from './InitialPrompts';
import { AImodels, defaultModelConfig } from '~/lib/ai-models';
import type { AIModelConfig } from '~/lib/ai-models';
import { FourSquare } from 'react-loading-indicators';
import { useScrollToBottom } from '~/hooks/useScrollToBottom';
import { FiArrowDown } from 'react-icons/fi';
import { useStreamingChat } from '~/components/chat/streaming-chat-context';

type ChatLoadingPhase = 'INITIALIZING' | 'PREPARING_CONTENT' | 'READY';

interface ChatPageLayoutProps {
  initialChatIdFromLoader: string | null;
  initialMessagesProp: Message[];
}

export function ChatPageLayout({
  initialChatIdFromLoader,
  initialMessagesProp,
}: ChatPageLayoutProps) {
  const navigate = useNavigate();
  const location = useLocation();
  const params = useParams();
  const urlChatId = params.chatId || null;

  const remixNavigation = useRemixNavigation();
  const [isReactTransitionPending, startReactTransition] = useReactTransitionHook();

  const streamChat = useStreamingChat();

  const [input, setInput] = useState('');
  const [selectedModel, setSelectedModel] = useState<AIModelConfig>(defaultModelConfig);
  const [chatPhase, setChatPhase] = useState<ChatLoadingPhase>('INITIALIZING');
  // Add a local state to prevent multiple context clears during navigation
  const [hasInitialized, setHasInitialized] = useState(false);

  const {
    containerRef,
    endRef,
    showScrollDownButton,
    scrollToBottom,
  } = useScrollToBottom(streamChat.messages);

  // Effect 1: Core logic to initialize or update chat context
  useEffect(() => {
    if (hasInitialized && remixNavigation.state !== 'idle') {
      // Don't re-initialize during navigation transitions
      return;
    }

    const navState = location.state as { fromNewChatFlow?: boolean; initialMessages?: Message[] } | null;
    console.log(`ChatPageLayout E1: urlChatId=${urlChatId}, initialChatIdFromLoader=${initialChatIdFromLoader}, contextUIFocus=${streamChat.currentUIFocusChatId}, contextActiveStream=${streamChat.activeStreamChatId}, navState=${JSON.stringify(navState)}, initialMessagesPropCt=${initialMessagesProp.length}`);

    setChatPhase('INITIALIZING');

    // Scenario 1: Landed on a specific chat URL (e.g., /chat/:id)
    if (urlChatId) {
      let messagesToUse: Message[] = initialMessagesProp;
      if (streamChat.activeStreamChatId === urlChatId &&
        streamChat.messages.length > 0 &&
        initialMessagesProp.length === 0) {
        console.log(`ChatPageLayout E1: Using existing messages from context (Stream active for this ID, initialProp empty).`);
        messagesToUse = [...streamChat.messages]; // Use existing context messages
      }
      // Special handling for navigation from new chat flow
      if (navState?.fromNewChatFlow && streamChat.activeStreamChatId === urlChatId) {
        console.log(`ChatPageLayout E1: Landed on ${urlChatId} from new chat flow. Context is active for this ID. Using context messages.`);
        messagesToUse = [...streamChat.messages]; // Use existing context (which might have streaming content)
      } else if (navState?.fromNewChatFlow && navState.initialMessages) {
        console.log(`ChatPageLayout E1: Landed on ${urlChatId} from new chat flow. Context NOT active for this ID. Using navState messages.`);
        messagesToUse = navState.initialMessages;
      } else if (streamChat.currentUIFocusChatId !== urlChatId) {
        // Only clear and reset if we're switching to a different chat
        console.log(`ChatPageLayout E1: Switching to chat ${urlChatId}. Previous focus: ${streamChat.currentUIFocusChatId}`);
        // Don't clear during an active stream
        if (!streamChat.isStreaming || streamChat.activeStreamChatId !== urlChatId) {
          streamChat.clearStreamState();
        }
      }

      // Always set messages for the current context
      streamChat.setMessagesForContext(messagesToUse, urlChatId);

      // Clean up navigation state if it was used
      if (navState?.fromNewChatFlow) {
        startReactTransition(() => {
          const { state, ...restOfLocation } = location;
          const { fromNewChatFlow: _fNCF, initialMessages: _iM, ...newStateWithoutFlow } = (state as any) || {};
          navigate(restOfLocation, { replace: true, state: Object.keys(newStateWithoutFlow).length > 0 ? newStateWithoutFlow : undefined });
        });
      }
      setChatPhase('PREPARING_CONTENT');
    }
    // Scenario 2: On a new chat page (urlChatId is null)
    else if (!urlChatId) {
      console.log("ChatPageLayout E1: Initializing for new chat page (urlChatId is null).");

      // Only clear if we're coming from a different chat or if there's stale data
      if (streamChat.currentUIFocusChatId !== null ||
        (streamChat.messages.length > 0 && !streamChat.isStreaming)) {
        console.log("ChatPageLayout E1: Clearing context for new chat page.");
        streamChat.clearStreamState();
      } else {
        console.log("ChatPageLayout E1: Context seems aligned for new/unnamed chat or is pristine. Not clearing.");
      }
      setChatPhase('READY');
    }

    setHasInitialized(true);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [urlChatId, initialMessagesProp, location.pathname]);

  // Reset initialization flag when URL changes
  useEffect(() => {
    return () => {
      setHasInitialized(false);
    };
  }, [location.pathname]);

  // Effect 2: Handle PREPARING_CONTENT phase
  useEffect(() => {
    if (chatPhase === 'PREPARING_CONTENT' && streamChat.currentUIFocusChatId === urlChatId && urlChatId) {
      console.log(`ChatPageLayout E2: PREPARING_CONTENT for ${urlChatId} -> READY. Scrolling history.`);
      startReactTransition(() => {
        setChatPhase('READY');
        const navState = location.state as { fromNewChatFlow?: boolean } | null;
        if (!navState?.fromNewChatFlow) { // Only scroll if not just landed from new chat flow
          requestAnimationFrame(() => scrollToBottom('auto'));
        }
      });
    }
  }, [chatPhase, urlChatId, streamChat.currentUIFocusChatId, scrollToBottom, location.state, startReactTransition]);

  const handleSendMessage = useCallback(
    async (inputTextValue: string, modelConfig: AIModelConfig) => {
      const trimmedInput = inputTextValue.trim();
      if (!trimmedInput || streamChat.isStreaming || isReactTransitionPending || chatPhase !== 'READY') {
        console.warn("ChatPageLayout: Send message aborted.", { isStreaming: streamChat.isStreaming, isReactTransitionPending, chatPhase });
        return;
      }
      setInput('');

      const userMessage: Message = {
        id: crypto.randomUUID(),
        role: 'user',
        content: trimmedInput,
        timestamp: Date.now()
      };

      if (!urlChatId) { // Current page is a "new chat" page
        const newChatId = uuidv4();
        console.log(`ChatPageLayout: New chat. Generated ID: ${newChatId}. Updating context, navigating, then streaming.`);

        try {
          // 1. Set context for the new chat ID with ONLY the user message
          //    This prepares the context before navigation and stream start.
          streamChat.setMessagesForContext([userMessage], newChatId);

          // 2. Navigate to the new chat's URL
          const destinationPath = `/chat/${newChatId}`;

          // 3. Start the stream BEFORE navigation completes
          // This ensures stream initialization isn't disrupted by navigation
          const streamPromise = streamChat.startStream(trimmedInput, modelConfig, newChatId);

          // 4. Navigate to new chat path
          startReactTransition(() => {
            navigate(destinationPath, {
              replace: true,
              state: { initialMessages: [userMessage], fromNewChatFlow: true },
            });
          });

          // 5. Await stream completion (in the background)
          await streamPromise;
        } catch (error) {
          console.error("Error in new chat flow:", error);
          // Handle error (could add error state to UI here)
        }
      } else { // Current page is an existing chat
        console.log(`ChatPageLayout: Existing chat ${urlChatId}. Sending message.`);
        try {
          // Add user message to existing messages in context
          streamChat.setMessagesForContext([...streamChat.messages, userMessage], urlChatId);
          await streamChat.startStream(trimmedInput, modelConfig, urlChatId);
        } catch (error) {
          console.error("Error in existing chat flow:", error);
          // Handle error (could add error state to UI here)
        }
      }
    },
    [streamChat, urlChatId, isReactTransitionPending, chatPhase, navigate, startReactTransition]
  );

  const handleFormSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    if (input.trim() && chatPhase === 'READY' && !streamChat.isStreaming && !isReactTransitionPending) {
      handleSendMessage(input, selectedModel);
    }
  };

  const handlePromptSelect = (promptText: string) => {
    if (chatPhase === 'READY' && !streamChat.isStreaming && !isReactTransitionPending) {
      setInput(promptText);
      handleSendMessage(promptText, selectedModel);
    }
  };

  const isRemixNavigating = remixNavigation.state !== 'idle';
  const showPageLoader = chatPhase !== 'READY' || isRemixNavigating || isReactTransitionPending;

  const displayInitialPrompts =
    !urlChatId &&
    streamChat.messages.length === 0 &&
    !streamChat.isStreaming &&
    !input &&
    chatPhase === 'READY';

  const showMessageAreaContent = chatPhase === 'READY' && !isRemixNavigating && !isReactTransitionPending;

  const childKey = urlChatId || "new-chat-page-active";

  return (
    <div className="flex flex-col h-full w-full">
      <div ref={containerRef} className="flex-grow overflow-y-auto overflow-x-hidden relative">
        {showPageLoader && (
          <div className="absolute inset-0 flex flex-col justify-center items-center bg-background/80 backdrop-blur-sm z-20 p-4 text-center">
            <FourSquare color="hsl(var(--primary))" size="medium" />
            <p className="mt-4 text-sm text-foreground">
              {isRemixNavigating ? "Navigating..."
                : isReactTransitionPending ? "Processing..."
                  : chatPhase === 'INITIALIZING' ? "Initializing chat..."
                    : chatPhase === 'PREPARING_CONTENT' ? "Loading messages..."
                      : "Loading..."}
            </p>
            {streamChat.streamError && <p className="mt-2 text-destructive text-xs">Error: {streamChat.streamError}</p>}
          </div>
        )}
        <div
          style={{
            opacity: showMessageAreaContent ? 1 : 0,
            pointerEvents: showMessageAreaContent ? 'auto' : 'none',
            transition: 'opacity 0.2s ease-in-out',
            minHeight: '100%', display: 'flex', flexDirection: 'column',
          }}
          className="w-full"
        >
          {displayInitialPrompts ? (
            <div className="max-w-5xl mx-auto w-full h-full flex flex-col justify-center items-center p-4 flex-grow">
              <InitialPrompts onPromptSelect={handlePromptSelect} />
            </div>
          ) : (
            <div className="max-w-4xl mx-auto w-full flex-grow flex flex-col">
              <MessageList
                key={`ml-${childKey}`}
                messages={streamChat.messages}
                isLoading={streamChat.isStreaming && streamChat.messages[streamChat.messages.length - 1]?.role === 'assistant' && streamChat.messages[streamChat.messages.length - 1]?.isLoading === true}
                isInitialHistoryLoading={chatPhase === 'PREPARING_CONTENT'}
                scrollEndRef={endRef}
              />
            </div>
          )}
        </div>

        {showScrollDownButton && (
          <div className="sticky bottom-4 w-full flex justify-center pointer-events-none z-30">
            <div className="max-w-4xl w-full flex justify-end pointer-events-auto px-4">
              <button
                onClick={() => scrollToBottom('smooth')}
                className="p-2 bg-card border border-border rounded-full shadow-lg hover:bg-muted focus:outline-none focus-visible:ring-2 focus-visible:ring-primary focus-visible:ring-offset-2 focus-visible:ring-offset-background transition-all duration-150 ease-in-out animate-fade-in"
                aria-label="Scroll to latest messages"
                title="Scroll to latest messages"
                style={{ minWidth: 36, minHeight: 36, width: 36, height: 36 }}
              >
                <FiArrowDown size={16} aria-hidden="true" />
              </button>
            </div>
          </div>
        )}
      </div>

      <div className="flex-shrink-0 bg-background border-t border-border">
        <div className="max-w-4xl mx-auto w-full p-2 md:p-3">
          <ChatInputBar
            key={`cib-${childKey}`}
            input={input}
            onInputChange={e => setInput(e.target.value)}
            onSubmit={handleFormSubmit}
            isLoading={
              chatPhase !== 'READY' ||
              streamChat.isStreaming ||
              isRemixNavigating ||
              isReactTransitionPending
            }
            availableModels={AImodels}
            selectedModel={selectedModel}
            onModelChange={setSelectedModel}
          />
        </div>
      </div>
    </div>
  );
}
---- app/components/chat/ChatPageLayout copy.tsx ----
// app/components/ChatPageLayout.tsx (or wherever your ChatPageLayout is)
import { useState, useEffect, useCallback, useRef, useTransition } from 'react';
// If you want Remix's useTransition, use:
// import { useTransition } from '@remix-run/react';
import { useNavigate, useLocation } from '@remix-run/react';
import type { Message } from './MessageItem'; // Adjust path if necessary
import { MessageList } from './MessageList'; // Adjust path if necessary
import { ChatInputBar } from './ChatInputBar'; // Adjust path if necessary
import { InitialPrompts } from './InitialPrompts'; // Adjust path if necessary
import {
  AImodels,
  defaultModelConfig,
  defaultSystemPrompt,
  API_STREAM_URL,
} from '~/lib/ai-models'; // Adjust path if necessary
import type { AIModelConfig } from '~/lib/ai-models'; // Adjust path if necessary

interface ChatPageLayoutProps {
  initialChatId: string | null;
  initialMessages?: Message[];
}

export function ChatPageLayout({ initialChatId, initialMessages = [] }: ChatPageLayoutProps) {
  const navigate = useNavigate();
  const location = useLocation();
  // React 18's useTransition
  const [isPending, startTransition] = useTransition();

  const chatLayoutKey = initialChatId || 'new-chat-session';

  const [messages, setMessages] = useState<Message[]>(initialMessages);
  const [input, setInput] = useState('');
  const [isStreaming, setIsStreaming] = useState(false);
  const [selectedModel, setSelectedModel] = useState<AIModelConfig>(defaultModelConfig);

  const abortControllerRef = useRef<AbortController | null>(null);
  const messagesRef = useRef(messages);

  useEffect(() => {
    messagesRef.current = messages;
  }, [messages]);

  useEffect(() => {
    // Only reset messages if not streaming and initialMessages truly changed for the current chat
    // This avoids resetting messages if initialMessages from loader is stale due to navigation state
    if (!isStreaming && location.state?.fromNewChatFlow !== true) {
      if (JSON.stringify(initialMessages) !== JSON.stringify(messagesRef.current.slice(0, initialMessages.length))) {
        setMessages(initialMessages || []);
      }
    } else if (location.state?.fromNewChatFlow === true) {
      // If navigated from new chat flow, messages are already set via state, clear the flag
      // This assumes navigate state is cleared on subsequent navigations or reloads
      const { state, ...rest } = location;
      // @ts-ignore
      const { fromNewChatFlow, ...newState } = state;
      navigate(rest, { replace: true, state: Object.keys(newState).length > 0 ? newState : undefined });
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [initialMessages, chatLayoutKey]); // Removed isStreaming to allow initialMessages to update if chat ID changes


  useEffect(() => {
    // Abort any ongoing stream and reset state when chat context changes
    if (abortControllerRef.current) {
      abortControllerRef.current.abort("Chat context changed or component unmounting");
      abortControllerRef.current = null;
    }
    setIsStreaming(false); // Ensure streaming is false
    setInput(''); // Clear input

    // Set messages based on initialMessages from loader for the *current* chat ID
    // This effect runs when initialChatId changes, ensuring correct messages are loaded.
    setMessages(initialMessages || []);

    return () => {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort("Component unmounting or initialChatId changing");
        abortControllerRef.current = null;
      }
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [initialChatId]); // Depend only on initialChatId for resetting context

  const handleSendMessage = useCallback(async (inputText: string, modelConfig: AIModelConfig) => {
    if (isStreaming || isPending) return;

    setIsStreaming(true);
    setInput('');

    const newUserMessage: Message = { id: crypto.randomUUID(), role: 'user', content: inputText };
    setMessages(prev => [...prev, newUserMessage]);

    const assistantMessageId = crypto.randomUUID();
    setMessages(prev => [...prev, { id: assistantMessageId, role: 'assistant', content: '' }]);
    const currentAbortController = new AbortController();
    abortControllerRef.current = currentAbortController;
    let chatIdForRequest = initialChatId;

    let receivedChatIdFromStream: string | null = null;

    try {
      const response = await fetch(API_STREAM_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Accept': 'text/event-stream' },
        body: JSON.stringify({
          chatId: chatIdForRequest,
          message: inputText,
          provider: modelConfig.provider,
          model: modelConfig.model,
          systemPrompt: defaultSystemPrompt,
        }),
        signal: currentAbortController.signal,
        credentials: 'include',
      });

      if (currentAbortController.signal.aborted) return;
      if (!response.ok || !response.body) {
        const errorBody = await response.text().catch(() => "Failed to read error body");
        throw new Error(`API Error ${response.status}: ${errorBody.slice(0, 500)}`);
      }

      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = "";

      // eslint-disable-next-line no-constant-condition
      while (true) {
        const { done, value } = await reader.read();
        if (currentAbortController.signal.aborted || done) break;

        buffer += decoder.decode(value, { stream: true });
        let newlineIndex;
        while ((newlineIndex = buffer.indexOf('\n')) >= 0) {
          const line = buffer.slice(0, newlineIndex).trim();
          buffer = buffer.slice(newlineIndex + 1);

          if (line.startsWith("data: ")) {
            const jsonDataString = line.substring(5);
            if (jsonDataString) {
              if (currentAbortController.signal.aborted) break;
              try {
                const chunk = JSON.parse(jsonDataString);
                if (chunk.type === "session_info" && chunk.chatId && !initialChatId) {
                  receivedChatIdFromStream = chunk.chatId;
                }
                handleStreamData(chunk, assistantMessageId);
              } catch (e) {
                if (!currentAbortController.signal.aborted)
                  console.error("Error parsing stream data JSON:", e, jsonDataString);
              }
            }
          }
        }
      }

      if (!initialChatId && receivedChatIdFromStream) {
        // Important: messagesRef.current will have the latest messages *including the streamed response*
        // because setMessages in handleStreamData updates it.
        startTransition(() => {
          navigate(`/chat/${receivedChatIdFromStream}`, {
            replace: true,
            state: { initialMessages: messagesRef.current, fromNewChatFlow: true }
          });
        });
        // setIsStreaming(false) will effectively be handled by the component re-keying or unmounting/remounting
        // due to navigation and change in initialChatId.
      } else {
        // If it's an existing chat or no chatId was received (should not happen for new chat success)
        // ensure streaming state is properly turned off if not already done by stream_end.
        // This check for abort is important here.
        if (!currentAbortController.signal.aborted) {
          setIsStreaming(false);
        }
      }
    } catch (error: any) {
      if (error.name === 'AbortError') {
        // Only update if the message doesn't already indicate abortion
        setMessages(prev =>
          prev.map(msg =>
            msg.id === assistantMessageId && msg.role === 'assistant' && !msg.content.includes("[Stream aborted]")
              ? { ...msg, content: (msg.content || "") + `\n[Stream aborted]` }
              : msg
          ));
      } else {
        console.error(`Send/Stream error:`, error);
        handleStreamError(assistantMessageId, error.message || "Failed to get response.");
      }
    } finally {
      if (abortControllerRef.current === currentAbortController) {
        abortControllerRef.current = null;
      }
      // If the navigation didn't happen (e.g., existing chat) and stream wasn't aborted,
      // ensure streaming is set to false. This is a fallback.
      // However, if navigation happens, the component might unmount/re-key which resets state.
      if (!receivedChatIdFromStream && !currentAbortController.signal.aborted) {
        setIsStreaming(false);
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [initialChatId, isStreaming, selectedModel, navigate, isPending, startTransition]);

  const handleStreamData = (chunk: any, assistantMessageId: string) => {
    // Check if the stream was aborted by a new action or component unmount
    if (abortControllerRef.current?.signal.aborted && !isStreaming) {
      // If isStreaming is false, it means the stream was likely ended or aborted intentionally
      // and we should not process further data for this assistant message.
      return;
    }

    if (chunk.content) {
      setMessages(prev =>
        prev.map(msg =>
          msg.id === assistantMessageId && msg.role === 'assistant'
            ? { ...msg, content: msg.content + chunk.content }
            : msg
        )
      );
    } else if (chunk.type === 'usage_summary' || chunk.type === 'stream_end') {
      // Only set isStreaming to false if the current abort controller is still active
      // or if there's no active abort controller (implying natural end).
      // This prevents race conditions if a new message was sent quickly.
      if (!abortControllerRef.current || !abortControllerRef.current.signal.aborted) {
        setIsStreaming(false);
      }
    } else if (chunk.error) {
      handleStreamError(assistantMessageId, chunk.error.message || chunk.error);
    }
  };

  const handleStreamError = (assistantMessageId: string, errorMessage: string) => {
    setMessages(prev =>
      prev.map(msg =>
        msg.id === assistantMessageId && msg.role === 'assistant' && !msg.content.includes("[Error:")
          ? { ...msg, content: (msg.content || "") + `\n[Error: ${errorMessage}]` }
          : msg
      )
    );
    // Ensure streaming is stopped on error, if not already aborted by a new request
    if (!abortControllerRef.current || !abortControllerRef.current.signal.aborted) {
      setIsStreaming(false);
    }
  };

  const handleFormSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    if (input.trim() && !isStreaming && !isPending) {
      handleSendMessage(input.trim(), selectedModel);
    }
  };

  const handlePromptSelect = (promptText: string) => {
    if (!isStreaming && !isPending) {
      // Set input for immediate display, then send
      setInput(promptText);
      handleSendMessage(promptText, selectedModel);
    }
  };

  const isNavigating = isPending; // useTransition's pending state
  const displayInitialPrompts =
    initialChatId === null &&
    messages.length === 0 &&
    !isStreaming &&
    !input &&
    !isNavigating;

  // Use initialChatId for keying child components that depend on chat context
  const childKey = initialChatId || "new-chat-internal";

  return (
    // Root div: takes full height and width from parent (AppLayout's main area)
    // flex flex-col ensures children (message area and input bar) are stacked vertically
    <div className="flex flex-col h-full w-full">

      {/* Message List Area:
          - flex-grow: takes up all available vertical space after input bar is accounted for.
          - overflow-y-auto: enables vertical scrolling ONLY for this area.
          - The scrollbar will appear on the right edge of THIS div.
      */}
      <div className="flex-grow overflow-y-auto">
        {displayInitialPrompts ? (
          // Container for InitialPrompts, centered within the scrollable area
          // max-w-4xl mx-auto ensures content is centered horizontally
          // h-full allows vertical centering content using flex
          // p-4 for padding
          <div className="max-w-4xl mx-auto w-full h-full flex flex-col justify-center items-center p-4">
            <InitialPrompts onPromptSelect={handlePromptSelect} />
          </div>
        ) : (
          // Container for MessageList
          // max-w-4xl mx-auto ensures messages are centered horizontally
          // w-full ensures it uses the available width up to max-w-4xl
          // p-4 provides padding around the message list. Consider pb-0 if MessageList handles last item spacing.
          <div className="max-w-4xl mx-auto w-full p-4">
            <MessageList
              key={`ml-${childKey}`} // Keyed to re-render if chat changes
              messages={messages}
              isLoading={isStreaming && !isNavigating} // Show loading indicator if streaming and not navigating away
            />
          </div>
        )}
      </div>

      {/* Chat Input Bar Area:
          - flex-shrink-0: prevents this area from shrinking.
          - bg-background, border-t, border-border: styling.
      */}
      <div className="flex-shrink-0 bg-background border-t border-border">
        {/* Content wrapper for ChatInputBar:
            - max-w-4xl mx-auto: centers the input bar content.
            - w-full: ensures it takes full width up to max-w-4xl.
            - p-2 md:p-3: original padding.
        */}
        <div className="max-w-4xl mx-auto w-full p-2 md:p-3">
          <ChatInputBar
            key={`cib-${childKey}`} // Keyed to re-render if chat changes
            input={input}
            onInputChange={e => setInput(e.target.value)}
            onSubmit={handleFormSubmit}
            isLoading={isStreaming || isNavigating} // Input disabled if streaming or navigating
            availableModels={AImodels}
            selectedModel={selectedModel}
            onModelChange={setSelectedModel}
          />
        </div>
      </div>
    </div>
  );
}
---- app/routes/__app.tsx ----
// app/routes/__app.tsx
import type { LoaderFunctionArgs } from "@remix-run/node";  
import { json } from "@remix-run/node";  
import { Outlet, useLoaderData } from "@remix-run/react";  
  
import { requireAuth, type AuthenticatedUserDetails } from "~/lib/auth.server";  
import { AppSidebar } from "~/components/app-sidebar";  
import { SidebarProvider, SidebarInset, SidebarTrigger } from "~/components/ui/sidebar";  
import type { NavItem } from "~/components/sidebar-nav";  
import { Separator } from "~/components/ui/separator";
import { StreamingChatProvider } from "~/components/chat/streaming-chat-context";
// ADD THIS IMPORT
  
export interface AppLoaderData {  
  user: AuthenticatedUserDetails;  
  appName: string;  
  mainNavItems: NavItem[];  
}  
  
export async function loader({ request }: LoaderFunctionArgs) {  
  await requireAuth(request);  
  return json<AppLoaderData>({  
    user: {  
      id: "dummy",  
      name: "Dummy",  
      email: "dummy@example.com",  
      avatar_url: "/avatars/default.png",  
    },  
    appName: "Krivi AI",  
    mainNavItems: [],  
  });  
}  
  
export default function AppLayout() {  
  const { user, appName, mainNavItems } = useLoaderData<typeof loader>();  
  const sidebarUser = {  
    name: user.name,  
    email: user.email,  
    avatar: "/avatars/default.png",  
  };  
  
  return (  
    // WRAP THE ENTIRE SIDEBAR PROVIDER (OR JUST THE OUTLET PART IF SIDEBAR IS NOT CHAT RELATED)
    // WITH STREAMINGCHATPROVIDER. For chat apps, often the whole app structure is relevant.
    <StreamingChatProvider> 
      <SidebarProvider>  
        <AppSidebar  
          user={sidebarUser}  
          appName={appName}  
          mainNav={mainNavItems}  
        />  
        <SidebarInset>  
          <div className="relative flex flex-col h-[100dvh] min-h-0 w-full">  
            <header  
              className="  
                sticky top-0 left-0 right-0 z-30 flex  
                h-[41px] md:h-[62px]  
                shrink-0 items-center gap-2 border-b border-border bg-background  
              "  
            >  
              <div className="flex items-center gap-2 px-4">  
                <SidebarTrigger className="-ml-1" />  
                <Separator orientation="vertical" className="mr-2 h-4 bg-border" />  
              </div>  
            </header>  
            <main className="relative flex-1 min-h-0 w-full flex flex-col">  
              {/* Outlet is where your /chat and /chat/:id routes render */}
              <Outlet /> 
            </main>  
          </div>  
        </SidebarInset>  
      </SidebarProvider>
    </StreamingChatProvider> 
  );  
}
---- app/routes/__app.chat.$chatId.tsx ----
// app/routes/__app.chat.$chatId.tsx
import { useLoaderData, useLocation, useParams } from "@remix-run/react";
import { json, LoaderFunctionArgs, MetaFunction } from "@remix-run/node";
import { requireAuth } from "~/lib/auth.server";
import { ChatPageLayout } from "~/components/chat/ChatPageLayout";
import type { Message } from "~/components/chat/MessageItem";
import { API_HISTORY_URL_BASE } from "~/lib/ai-models";

// ... (meta function and loader remain the same)
export const meta: MetaFunction = ({ params }) => [{ title: `Chat ${params.chatId ? `- ${params.chatId.substring(0,8)}` : ''} | Krivi AI` }];

interface LoaderData {
  chatId: string;
  initialMessages: Message[];
  error?: string;
}

export async function loader({ request, params }: LoaderFunctionArgs): Promise<ReturnType<typeof json<LoaderData>>> {
  await requireAuth(request);
  const chatId = params.chatId;

  if (!chatId) {
    throw new Response("Chat ID missing in params", { status: 404 });
  }

  let messagesFromHistory: Message[] = [];
  const historyUrl = `${API_HISTORY_URL_BASE.replace(/\/$/, '')}/${chatId}/history?limit=50`;

  try {
    const response = await fetch(historyUrl, {
      method: 'GET',
      headers: { 'Cookie': request.headers.get('Cookie') || '' },
    });

    if (response.ok) {
      const data = await response.json();
      if (data.messages && Array.isArray(data.messages)) {
        messagesFromHistory = data.messages.map((msg: any) => ({
          id: msg.id || crypto.randomUUID(), 
          role: msg.role, 
          content: msg.content, 
          timestamp: msg.createdAt || msg.timestamp ? new Date(msg.createdAt || msg.timestamp).getTime() : undefined,
        }));
      }
    } else {
      console.error(`Failed to fetch chat history for ${chatId}: ${response.status} ${response.statusText}`);
      return json({ chatId, initialMessages: [], error: `Failed to load history: ${response.status}` });
    }
  } catch (error: any) {
    console.error(`Error fetching chat history for ${chatId}:`, error);
    return json({ chatId, initialMessages: [], error: `Error loading chat: ${error.message}` });
  }
  return json({ chatId, initialMessages: messagesFromHistory });
}


export default function ChatWithIdPage() {
  const loaderData = useLoaderData<LoaderData>();
  const location = useLocation();
  const params = useParams(); // Use params for the key and current ID

  const navState = location.state as { initialMessages?: Message[], fromNewChatFlow?: boolean } | null;
  
  // Default to loader data. ChatPageLayout will further refine based on context and navState.
  let finalInitialMessages = loaderData.initialMessages;

  // This logic is simplified because ChatPageLayout's Effect 1 now has more robust handling
  // of messages from navState vs. loaderData vs. existing context state.
  if (navState?.fromNewChatFlow && navState.initialMessages && params.chatId === loaderData.chatId) {
      // We can still prefer navState messages if it's an immediate navigation
      // and ChatPageLayout will reconcile with context.
      finalInitialMessages = navState.initialMessages;
  }
  
  if (loaderData.error) {
    console.error("Error in loader for ChatWithIdPage:", loaderData.error);
  }

  return (
    <ChatPageLayout
      key={params.chatId} 
      initialChatIdFromLoader={loaderData.chatId} // Pass loader's chatId
      initialMessagesProp={finalInitialMessages}
    />
  );
}
---- app/routes/login.tsx ----
// app/routes/login.tsx
import type { LoaderFunctionArgs, MetaFunction } from "@remix-run/node";
import { json, redirect } from "@remix-run/node";
import { useLoaderData, useSearchParams } from "@remix-run/react";
import { FaGoogle } from "react-icons/fa";

import { Button } from "~/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "~/components/ui/card";
import {
  checkAuth,
  refreshTokens,
  isAuthenticated,
  isRefreshable,
  type AuthStatus, // Type import is fine from .server files
} from "~/lib/auth.server";
import { getApiUrl } from "~/lib/api.config"; // Import getApiUrl from client-safe config
import { useIsMobile } from "~/hooks/use-mobile";

export const meta: MetaFunction = () => {
  return [{ title: "Sign In" }];
};

export async function loader({ request }: LoaderFunctionArgs) {
  const url = new URL(request.url);
  const responseHeaders = new Headers();

  let authStatus = await checkAuth(request);

  if (isRefreshable(authStatus)) {
    console.log("[Login Loader] Token refresh required. Attempting refresh...");
    const { ok, setCookieHeader } = await refreshTokens(request);
    if (ok && setCookieHeader) {
      responseHeaders.append("Set-Cookie", setCookieHeader);
      const destination = url.pathname + url.search;
      console.log(`[Login Loader] Refresh successful. Redirecting to ${destination} to apply new cookies.`);
      throw redirect(destination, { headers: responseHeaders });
    }
    authStatus = await checkAuth(request); // Re-check auth after failed refresh
    console.log("[Login Loader] Refresh failed or no cookies set. New auth status:", authStatus.status);
  }

  if (isAuthenticated(authStatus)) {
    const next = url.searchParams.get("next") || "/"; // Default to app's root
    console.log(`[Login Loader] User already authenticated. Redirecting to: ${next}`);
    throw redirect(next, { headers: responseHeaders });
  }

  return json({ authStatus }, { headers: responseHeaders });
}

export default function LoginPage() {  
  const { authStatus } = useLoaderData<typeof loader>();  
  const [searchParams] = useSearchParams();  
  const isMobile = useIsMobile();  
  
  const googleLoginUrl = getApiUrl("GOOGLE_LOGIN");  
  const nextParam = searchParams.get("next");  
  const finalGoogleLoginUrl = nextParam  
    ? `${googleLoginUrl}?final_redirect_path=${encodeURIComponent(nextParam)}`  
    : googleLoginUrl;  
  
  // User-friendly error translation  
  const ERROR_MESSAGES: Record<string, string | undefined> = {  
    session_terminated: "Your session has been terminated. Please sign in again.",  
    invalid_or_expired_tokens: "Your session is invalid or has expired. Please sign in again.",  
    auth_check_failed: "Something went wrong. Please try signing in again.",  
    // add other codes as needed  
  };  
  
  let displayMessage = searchParams.get("message");  
  let errorReason = searchParams.get("error_description") || searchParams.get("error");  
  
  if (!displayMessage && !errorReason && authStatus) {  
    if (authStatus.status === "login_required") {  
      errorReason = ERROR_MESSAGES[authStatus.reason] ?? "";  
    } else if (authStatus.status === "error") {  
      errorReason = ERROR_MESSAGES[authStatus.reason ?? ""] ?? "Something went wrong. Please try signing in again.";  
    }  
  }  
  
  // Never show technical/unknown or empty codes to user  
  if (  
    !errorReason ||  
    ["no_tokens_present", "auth_check_failed", "error", "login_required"].includes(errorReason)  
  ) {  
    errorReason = "";  
  }  
  
  return (  
    <div className="flex min-h-screen items-center justify-center bg-background px-4 py-12">  
      <Card className="w-full max-w-md shadow-xl">  
        <CardHeader className="text-center">  
          <CardTitle className="text-3xl font-bold tracking-tight text-primary">  
            Access Your Account  
          </CardTitle>  
          <CardDescription className="text-muted-foreground pt-2">  
            Continue with Google to securely sign in.  
          </CardDescription>  
        </CardHeader>  
        <CardContent className="space-y-6 pt-6">  
          {errorReason && (  
            <div className="rounded-md border border-destructive/50 bg-destructive/10 p-3 text-center text-sm text-destructive">  
              <p>{errorReason}</p>  
            </div>  
          )}  
          {displayMessage && !errorReason && (  
            <div className="rounded-md border border-primary/50 bg-primary/10 p-3 text-center text-sm text-primary">  
              <p>{displayMessage}</p>  
            </div>  
          )}  
          <Button  
            asChild  
            size={isMobile ? "lg" : "lg"}  
            className="w-full bg-primary text-primary-foreground hover:bg-primary/90 text-lg py-6"  
          >  
            <a href={finalGoogleLoginUrl} className="flex items-center justify-center gap-3">  
              <FaGoogle className="h-5 w-5" />  
              Sign in with Google  
            </a>  
          </Button>  
        </CardContent>  
        <CardFooter className="flex-col items-center text-center pt-6">  
          <p className="text-xs text-muted-foreground">  
            By proceeding, you agree to our Terms of Service and Privacy Policy.  
          </p>  
        </CardFooter>  
      </Card>  
    </div>  
  );  
}  
---- app/routes/__app._index.tsx ----
// app/routes/__app._index.tsx
import { json, LoaderFunctionArgs, MetaFunction } from "@remix-run/node";
import { useLoaderData } from "@remix-run/react";
import { ChatPageLayout } from "~/components/chat/ChatPageLayout";
import { requireAuth } from "~/lib/auth.server";
import type { Message } from "~/components/chat/MessageItem";

export const meta: MetaFunction = () => [{ title: "New Chat | Krivi AI" }];

export async function loader({ request }: LoaderFunctionArgs) {
  await requireAuth(request);
  return json({
    initialChatId: null,
    initialMessages: [],
  });
}

export default function AppRootNewChatPage() {
  const { initialChatId, initialMessages } = useLoaderData<{
    initialChatId: null;
    initialMessages: Message[];
  }>();

  return (
    <ChatPageLayout
      key="new-chat-page" // Stable key for the new chat page instance
      initialChatIdFromLoader={initialChatId}
      initialMessagesProp={initialMessages}
    />
  );
}
---- app/hooks/use-mobile.tsx ----
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    // Ensure window is defined (for SSR safety, though matchMedia is client-only)
    if (typeof window === 'undefined') {
      setIsMobile(false); // Default for server or non-browser env
      return;
    }

    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    // Add listener
    mql.addEventListener("change", onChange)
    // Set initial state
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    // Clean up listener
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}
---- app/hooks/useScrollToBottom.ts ----
// app/hooks/useScrollToBottom.ts

import { useRef, useState, useEffect, useCallback } from 'react';
import { Message } from '~/components/chat/MessageItem';

const INTERSECTION_THRESHOLD_PX = 30; // MODIFIED: Was 50, now 30
const USER_SCROLL_DEBOUNCE_MS = 150;

export function useScrollToBottom(messages: Message[]) {
  const containerRef = useRef<HTMLDivElement | null>(null);
  const endRef = useRef<HTMLDivElement | null>(null);

  const [isAtBottom, setIsAtBottom] = useState(true);
  const [showScrollDownButton, setShowScrollDownButton] = useState(false);
  const scrollTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  const scrollToBottom = useCallback((behavior: ScrollBehavior = 'smooth') => {
    const scrollableContainer = containerRef.current;
    const bottomMarker = endRef.current;

    if (bottomMarker) {
      bottomMarker.scrollIntoView({ behavior });
    } else if (scrollableContainer) {
      scrollableContainer.scrollTo({
        top: scrollableContainer.scrollHeight,
        behavior,
      });
    }
    setIsAtBottom(true);
    setShowScrollDownButton(false);
  }, []);

  useEffect(() => {
    const scrollableContainer = containerRef.current;
    const bottomMarker = endRef.current;

    if (!scrollableContainer || !bottomMarker) {
      setIsAtBottom(true);
      setShowScrollDownButton(false);
      return;
    }

    const observer = new IntersectionObserver(
      ([entry]) => {
        const isCurrentlyIntersecting = entry.isIntersecting;
        setIsAtBottom(isCurrentlyIntersecting);
        setShowScrollDownButton(!isCurrentlyIntersecting);
      },
      {
        root: scrollableContainer,
        rootMargin: `0px 0px ${INTERSECTION_THRESHOLD_PX}px 0px`,
        threshold: 0.01,
      }
    );
    observer.observe(bottomMarker);

    if (
      scrollableContainer.scrollHeight > scrollableContainer.clientHeight &&
      scrollableContainer.scrollTop + scrollableContainer.clientHeight < scrollableContainer.scrollHeight - INTERSECTION_THRESHOLD_PX
    ) {
      setIsAtBottom(false);
      setShowScrollDownButton(true);
    } else {
      setIsAtBottom(true);
      setShowScrollDownButton(false);
    }

    return () => {
      observer.unobserve(bottomMarker);
      observer.disconnect();
    };
  }, [containerRef, endRef]); // Removed INTERSECTION_THRESHOLD_PX from deps as it's const now

  useEffect(() => {
    const scrollableContainer = containerRef.current;
    if (!scrollableContainer) return;

    const handleScroll = () => {
      if (scrollTimeoutRef.current) clearTimeout(scrollTimeoutRef.current);

      scrollTimeoutRef.current = setTimeout(() => {
        if (scrollableContainer) {
          const { scrollTop, scrollHeight, clientHeight } = scrollableContainer;
          const isNearBottom =
            scrollHeight - scrollTop - clientHeight <
            INTERSECTION_THRESHOLD_PX + 5; 

          if (!isNearBottom) {
            if (!showScrollDownButton) setShowScrollDownButton(true);
            if (isAtBottom) setIsAtBottom(false);
          } else {
            if (showScrollDownButton) setShowScrollDownButton(false);
            if (!isAtBottom) setIsAtBottom(true);
          }
        }
      }, USER_SCROLL_DEBOUNCE_MS);
    };

    scrollableContainer.addEventListener('scroll', handleScroll, { passive: true });
    return () => {
      scrollableContainer.removeEventListener('scroll', handleScroll);
      if (scrollTimeoutRef.current) clearTimeout(scrollTimeoutRef.current);
    };
  }, [containerRef, showScrollDownButton, isAtBottom]); // Removed INTERSECTION_THRESHOLD_PX from deps

  return {
    containerRef,
    endRef,
    isAtBottom,
    showScrollDownButton,
    scrollToBottom,
  };
}
---- app/routes/__app.tsx ----
// app/routes/__app.tsx
import type { LoaderFunctionArgs } from "@remix-run/node";  
import { json } from "@remix-run/node";  
import { Outlet, useLoaderData } from "@remix-run/react";  
  
import { requireAuth, type AuthenticatedUserDetails } from "~/lib/auth.server";  
import { AppSidebar } from "~/components/app-sidebar";  
import { SidebarProvider, SidebarInset, SidebarTrigger } from "~/components/ui/sidebar";  
import type { NavItem } from "~/components/sidebar-nav";  
import { Separator } from "~/components/ui/separator";
import { StreamingChatProvider } from "~/components/chat/streaming-chat-context";
// ADD THIS IMPORT
  
export interface AppLoaderData {  
  user: AuthenticatedUserDetails;  
  appName: string;  
  mainNavItems: NavItem[];  
}  
  
export async function loader({ request }: LoaderFunctionArgs) {  
  await requireAuth(request);  
  return json<AppLoaderData>({  
    user: {  
      id: "dummy",  
      name: "Dummy",  
      email: "dummy@example.com",  
      avatar_url: "/avatars/default.png",  
    },  
    appName: "Krivi AI",  
    mainNavItems: [],  
  });  
}  
  
export default function AppLayout() {  
  const { user, appName, mainNavItems } = useLoaderData<typeof loader>();  
  const sidebarUser = {  
    name: user.name,  
    email: user.email,  
    avatar: "/avatars/default.png",  
  };  
  
  return (  
    // WRAP THE ENTIRE SIDEBAR PROVIDER (OR JUST THE OUTLET PART IF SIDEBAR IS NOT CHAT RELATED)
    // WITH STREAMINGCHATPROVIDER. For chat apps, often the whole app structure is relevant.
    <StreamingChatProvider> 
      <SidebarProvider>  
        <AppSidebar  
          user={sidebarUser}  
          appName={appName}  
          mainNav={mainNavItems}  
        />  
        <SidebarInset>  
          <div className="relative flex flex-col h-[100dvh] min-h-0 w-full">  
            <header  
              className="  
                sticky top-0 left-0 right-0 z-30 flex  
                h-[41px] md:h-[62px]  
                shrink-0 items-center gap-2 border-b border-border bg-background  
              "  
            >  
              <div className="flex items-center gap-2 px-4">  
                <SidebarTrigger className="-ml-1" />  
                <Separator orientation="vertical" className="mr-2 h-4 bg-border" />  
              </div>  
            </header>  
            <main className="relative flex-1 min-h-0 w-full flex flex-col">  
              {/* Outlet is where your /chat and /chat/:id routes render */}
              <Outlet /> 
            </main>  
          </div>  
        </SidebarInset>  
      </SidebarProvider>
    </StreamingChatProvider> 
  );  
}
---- app/routes/__app.chat.$chatId.tsx ----
// app/routes/__app.chat.$chatId.tsx
import { useLoaderData, useLocation, useParams } from "@remix-run/react";
import { json, LoaderFunctionArgs, MetaFunction } from "@remix-run/node";
import { requireAuth } from "~/lib/auth.server";
import { ChatPageLayout } from "~/components/chat/ChatPageLayout";
import type { Message } from "~/components/chat/MessageItem";
import { API_HISTORY_URL_BASE } from "~/lib/ai-models";

// ... (meta function and loader remain the same)
export const meta: MetaFunction = ({ params }) => [{ title: `Chat ${params.chatId ? `- ${params.chatId.substring(0,8)}` : ''} | Krivi AI` }];

interface LoaderData {
  chatId: string;
  initialMessages: Message[];
  error?: string;
}

export async function loader({ request, params }: LoaderFunctionArgs): Promise<ReturnType<typeof json<LoaderData>>> {
  await requireAuth(request);
  const chatId = params.chatId;

  if (!chatId) {
    throw new Response("Chat ID missing in params", { status: 404 });
  }

  let messagesFromHistory: Message[] = [];
  const historyUrl = `${API_HISTORY_URL_BASE.replace(/\/$/, '')}/${chatId}/history?limit=50`;

  try {
    const response = await fetch(historyUrl, {
      method: 'GET',
      headers: { 'Cookie': request.headers.get('Cookie') || '' },
    });

    if (response.ok) {
      const data = await response.json();
      if (data.messages && Array.isArray(data.messages)) {
        messagesFromHistory = data.messages.map((msg: any) => ({
          id: msg.id || crypto.randomUUID(), 
          role: msg.role, 
          content: msg.content, 
          timestamp: msg.createdAt || msg.timestamp ? new Date(msg.createdAt || msg.timestamp).getTime() : undefined,
        }));
      }
    } else {
      console.error(`Failed to fetch chat history for ${chatId}: ${response.status} ${response.statusText}`);
      return json({ chatId, initialMessages: [], error: `Failed to load history: ${response.status}` });
    }
  } catch (error: any) {
    console.error(`Error fetching chat history for ${chatId}:`, error);
    return json({ chatId, initialMessages: [], error: `Error loading chat: ${error.message}` });
  }
  return json({ chatId, initialMessages: messagesFromHistory });
}


export default function ChatWithIdPage() {
  const loaderData = useLoaderData<LoaderData>();
  const location = useLocation();
  const params = useParams(); // Use params for the key and current ID

  const navState = location.state as { initialMessages?: Message[], fromNewChatFlow?: boolean } | null;
  
  // Default to loader data. ChatPageLayout will further refine based on context and navState.
  let finalInitialMessages = loaderData.initialMessages;

  // This logic is simplified because ChatPageLayout's Effect 1 now has more robust handling
  // of messages from navState vs. loaderData vs. existing context state.
  if (navState?.fromNewChatFlow && navState.initialMessages && params.chatId === loaderData.chatId) {
      // We can still prefer navState messages if it's an immediate navigation
      // and ChatPageLayout will reconcile with context.
      finalInitialMessages = navState.initialMessages;
  }
  
  if (loaderData.error) {
    console.error("Error in loader for ChatWithIdPage:", loaderData.error);
  }

  return (
    <ChatPageLayout
      key={params.chatId} 
      initialChatIdFromLoader={loaderData.chatId} // Pass loader's chatId
      initialMessagesProp={finalInitialMessages}
    />
  );
}
---- app/routes/login.tsx ----
// app/routes/login.tsx
import type { LoaderFunctionArgs, MetaFunction } from "@remix-run/node";
import { json, redirect } from "@remix-run/node";
import { useLoaderData, useSearchParams } from "@remix-run/react";
import { FaGoogle } from "react-icons/fa";

import { Button } from "~/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "~/components/ui/card";
import {
  checkAuth,
  refreshTokens,
  isAuthenticated,
  isRefreshable,
  type AuthStatus, // Type import is fine from .server files
} from "~/lib/auth.server";
import { getApiUrl } from "~/lib/api.config"; // Import getApiUrl from client-safe config
import { useIsMobile } from "~/hooks/use-mobile";

export const meta: MetaFunction = () => {
  return [{ title: "Sign In" }];
};

export async function loader({ request }: LoaderFunctionArgs) {
  const url = new URL(request.url);
  const responseHeaders = new Headers();

  let authStatus = await checkAuth(request);

  if (isRefreshable(authStatus)) {
    console.log("[Login Loader] Token refresh required. Attempting refresh...");
    const { ok, setCookieHeader } = await refreshTokens(request);
    if (ok && setCookieHeader) {
      responseHeaders.append("Set-Cookie", setCookieHeader);
      const destination = url.pathname + url.search;
      console.log(`[Login Loader] Refresh successful. Redirecting to ${destination} to apply new cookies.`);
      throw redirect(destination, { headers: responseHeaders });
    }
    authStatus = await checkAuth(request); // Re-check auth after failed refresh
    console.log("[Login Loader] Refresh failed or no cookies set. New auth status:", authStatus.status);
  }

  if (isAuthenticated(authStatus)) {
    const next = url.searchParams.get("next") || "/"; // Default to app's root
    console.log(`[Login Loader] User already authenticated. Redirecting to: ${next}`);
    throw redirect(next, { headers: responseHeaders });
  }

  return json({ authStatus }, { headers: responseHeaders });
}

export default function LoginPage() {  
  const { authStatus } = useLoaderData<typeof loader>();  
  const [searchParams] = useSearchParams();  
  const isMobile = useIsMobile();  
  
  const googleLoginUrl = getApiUrl("GOOGLE_LOGIN");  
  const nextParam = searchParams.get("next");  
  const finalGoogleLoginUrl = nextParam  
    ? `${googleLoginUrl}?final_redirect_path=${encodeURIComponent(nextParam)}`  
    : googleLoginUrl;  
  
  // User-friendly error translation  
  const ERROR_MESSAGES: Record<string, string | undefined> = {  
    session_terminated: "Your session has been terminated. Please sign in again.",  
    invalid_or_expired_tokens: "Your session is invalid or has expired. Please sign in again.",  
    auth_check_failed: "Something went wrong. Please try signing in again.",  
    // add other codes as needed  
  };  
  
  let displayMessage = searchParams.get("message");  
  let errorReason = searchParams.get("error_description") || searchParams.get("error");  
  
  if (!displayMessage && !errorReason && authStatus) {  
    if (authStatus.status === "login_required") {  
      errorReason = ERROR_MESSAGES[authStatus.reason] ?? "";  
    } else if (authStatus.status === "error") {  
      errorReason = ERROR_MESSAGES[authStatus.reason ?? ""] ?? "Something went wrong. Please try signing in again.";  
    }  
  }  
  
  // Never show technical/unknown or empty codes to user  
  if (  
    !errorReason ||  
    ["no_tokens_present", "auth_check_failed", "error", "login_required"].includes(errorReason)  
  ) {  
    errorReason = "";  
  }  
  
  return (  
    <div className="flex min-h-screen items-center justify-center bg-background px-4 py-12">  
      <Card className="w-full max-w-md shadow-xl">  
        <CardHeader className="text-center">  
          <CardTitle className="text-3xl font-bold tracking-tight text-primary">  
            Access Your Account  
          </CardTitle>  
          <CardDescription className="text-muted-foreground pt-2">  
            Continue with Google to securely sign in.  
          </CardDescription>  
        </CardHeader>  
        <CardContent className="space-y-6 pt-6">  
          {errorReason && (  
            <div className="rounded-md border border-destructive/50 bg-destructive/10 p-3 text-center text-sm text-destructive">  
              <p>{errorReason}</p>  
            </div>  
          )}  
          {displayMessage && !errorReason && (  
            <div className="rounded-md border border-primary/50 bg-primary/10 p-3 text-center text-sm text-primary">  
              <p>{displayMessage}</p>  
            </div>  
          )}  
          <Button  
            asChild  
            size={isMobile ? "lg" : "lg"}  
            className="w-full bg-primary text-primary-foreground hover:bg-primary/90 text-lg py-6"  
          >  
            <a href={finalGoogleLoginUrl} className="flex items-center justify-center gap-3">  
              <FaGoogle className="h-5 w-5" />  
              Sign in with Google  
            </a>  
          </Button>  
        </CardContent>  
        <CardFooter className="flex-col items-center text-center pt-6">  
          <p className="text-xs text-muted-foreground">  
            By proceeding, you agree to our Terms of Service and Privacy Policy.  
          </p>  
        </CardFooter>  
      </Card>  
    </div>  
  );  
}  
---- app/routes/__app._index.tsx ----
// app/routes/__app._index.tsx
import { json, LoaderFunctionArgs, MetaFunction } from "@remix-run/node";
import { useLoaderData } from "@remix-run/react";
import { ChatPageLayout } from "~/components/chat/ChatPageLayout";
import { requireAuth } from "~/lib/auth.server";
import type { Message } from "~/components/chat/MessageItem";

export const meta: MetaFunction = () => [{ title: "New Chat | Krivi AI" }];

export async function loader({ request }: LoaderFunctionArgs) {
  await requireAuth(request);
  return json({
    initialChatId: null,
    initialMessages: [],
  });
}

export default function AppRootNewChatPage() {
  const { initialChatId, initialMessages } = useLoaderData<{
    initialChatId: null;
    initialMessages: Message[];
  }>();

  return (
    <ChatPageLayout
      key="new-chat-page" // Stable key for the new chat page instance
      initialChatIdFromLoader={initialChatId}
      initialMessagesProp={initialMessages}
    />
  );
}
---- app/lib/ai-models.ts ----
// app/lib/ai-models.ts
export interface AIModelConfig {
  displayName: string;
  model: string;
  provider: string;
  isDefault?: boolean; // Optional: useful for selecting default
}

export const AImodels: AIModelConfig[] = [
  {
    displayName: "GPT-4o Mini",
    model: "gpt-4o-mini",
    provider: "azure",
    isDefault: true, // Marking this as default as per your previous defaultModelConfig

  },
  {
    displayName: "Gemini 2.5 flash", // Updated display name to match model version (optional, adjust as needed)
    model: "gemini-2.5-flash-preview-04-17", // From your example payload
    provider: "google",
  },
  {
    displayName: "Gemini 2.0 flash", // Updated display name to match model version (optional, adjust as needed)
    model: "gemini-2.0-flash", // From your example payload
    provider: "google",
  }
  // Add more models here as needed
];

// Select default based on isDefault flag or fallback
export const defaultModelConfig: AIModelConfig = AImodels.find(m => m.isDefault) || AImodels[0];

export const defaultSystemPrompt = "You are a helpful assistant.";
export const API_STREAM_URL = "https://api-chat.kwikon.club/api/chat/stream";
export const API_HISTORY_URL_BASE = "https://api-chat.kwikon.club/api/chat/"; // e.g., append {chatId}/history