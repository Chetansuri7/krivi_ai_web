--- app/lib/utils.ts ---
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
export function isProbablyMobile(): boolean {
  if (typeof window !== "undefined") {
    if (window.matchMedia("(pointer: coarse)").matches) return true;
    // Broader check for mobile devices
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
      navigator.userAgent
    );
  }
  // Fallback for SSR or non-browser environments
  return false;
}--- app/lib/api.config.ts ---
/**
* SCALABLE AUTH FLOW (fetchWithHeaders)
* =====================================
* On any API call:
*   - If access token is expired (401), fetchWithHeaders calls /auth/check.
*   - If /auth/check returns { status: "refresh_required", reason: "valid_refresh_token" },
*     fetchWithHeaders POSTs to /auth/refresh.
*   - If refresh succeeds, fetchWithHeaders retries the original request ONCE with new tokens.
*   - If refresh fails, or /auth/check returns login_required, fetchWithHeaders returns the 401.
*   - UI code (route loaders or React) should redirect to login only if a request fails with 401 after retry.
*   - All token logic is centralized here; UI never needs to manually call /auth/refresh.
*   - Backend must ensure new tokens are sent as HttpOnly cookies on refresh.
*   - This ensures users are never forced to login again unless both tokens are invalid/expired.
*/
// app/lib/api.config.ts

// For client-side access in Remix + Vite, use VITE_ prefix for env vars
// Make sure VITE_API_BASE_URL is defined in your .env file

// Helper to get environment variables, works on client and server.
// Expects VITE_ prefixed keys for client-side access via import.meta.env.
const getEnv = (viteKey: string, defaultValue: string): string => {
  const val = typeof window !== 'undefined'
    ? (import.meta.env as any)[viteKey]    // Client-side (Vite)
    : process.env[viteKey];               // Server-side (Node.js)
  return val || defaultValue;
};

// Correctly access environment variables for client and server
export const API_BASE_URL = typeof window !== 'undefined' // Check if running in browser
  ? import.meta.env.VITE_API_BASE_URL // Client-side (Vite)
  : process.env.VITE_API_BASE_URL;   // Server-side (Node.js)

// This check is for build/server time.
if (!API_BASE_URL && typeof process !== 'undefined' && process.env.NODE_ENV !== 'production') {
  console.warn(
    "WARNING: VITE_API_BASE_URL environment variable is not set. Please define it in your .env file (e.g., VITE_API_BASE_URL=https://your-api.com)."
  );
}

// Environment-specific application settings
// Set these in your .env files (e.g., .env.development, .env.production).
// Example for development (.env.development):
// VITE_SUCCESS_REDIRECT_URI="https://dev-chat.krivilak.com/"
// VITE_COOKIE_DOMAIN=".krivilak.com" (can be same for dev/prod or more specific for dev like "localhost")
// VITE_GOOGLE_AUTH_REDIRECT_URI="https://api-dev-v0.krivilak.com/auth/google/callback"
// VITE_TOKEN_ISSUER_URI="https://api-dev-v0.krivilak.com"
//
// Example for production (.env or .env.production):
// VITE_SUCCESS_REDIRECT_URI="https://chat.krivilak.com/"
// VITE_COOKIE_DOMAIN=".krivilak.com"
// VITE_GOOGLE_AUTH_REDIRECT_URI="https://api.krivilak.com/auth/google/callback"
// VITE_TOKEN_ISSUER_URI="https://api.krivilak.com"

export const SUCCESS_REDIRECT_URI = getEnv("VITE_SUCCESS_REDIRECT_URI", "https://chat.krivilak.com/");
export const COOKIE_DOMAIN = getEnv("VITE_COOKIE_DOMAIN", ".krivilak.com");
export const GOOGLE_AUTH_REDIRECT_URI = getEnv("VITE_GOOGLE_AUTH_REDIRECT_URI", "https://api.krivilak.com/auth/google/callback");
export const TOKEN_ISSUER_URI = getEnv("VITE_TOKEN_ISSUER_URI", "https://api.krivilak.com");

export const API_ROUTES = {
  // Auth
  GOOGLE_LOGIN: "/auth/google/login",
  AUTH_REFRESH: "/auth/refresh",
  AUTH_CHECK: "/auth/check",
  AUTH_LOGOUT: "/auth/logout",

  // Chat - Ensure path starts with '/'
  CHAT_SESSION_LIST: "/api/chat/session_list",
  CHAT_STREAM: "/api/chat/stream",
  CHAT_HISTORY_BASE: "/api/chat", // Base path for history, e.g., /api/chat/{chatId}/history

  // Other API routes can be added here
  // EXAMPLE_DATA: "/api/example",
};

/**
 * Helper function to construct full API URLs.
 * @param routeKey A key from API_ROUTES
 * @returns The full URL for the API endpoint.
 */
export function getApiUrl(routeKey: keyof typeof API_ROUTES): string {
  if (!API_BASE_URL) {
    const errorMessage = `VITE_API_BASE_URL is not configured or not available. Cannot construct API URL for "${String(routeKey)}". Check your .env file and Vite/Remix configuration. Current URL: ${API_BASE_URL}`;
    console.error(errorMessage);
    throw new Error(errorMessage);
  }
  const path = API_ROUTES[routeKey];
  if (!path) {
    throw new Error(`API route for key "${String(routeKey)}" not found.`);
  }
  return `${API_BASE_URL}${path}`;
}
/**
 * A wrapper around the native fetch function that automatically adds
 * the 'X-Client-Platform: Web' header to requests.
 * It also uses getApiUrl to construct the full API URL if a routeKey is provided.
 *
 * @param input The resource that you wish to fetch. This can either be a string, a URL object, or a key from API_ROUTES.
 * @param init An object containing any custom settings that you want to apply to the request.
 * @returns A Promise that resolves to the Response to that request.
 */
export async function fetchWithHeaders(
  input: keyof typeof API_ROUTES | RequestInfo | URL,
  init?: RequestInit,
  _retry?: boolean // Internal flag to prevent infinite retry
): Promise<Response> {
  const headers = new Headers(init?.headers);
  headers.set('X-Client-Platform', 'Web');

  const newInit = {
    ...init,
    headers,
    credentials: 'include' as RequestCredentials, // Ensure cookies are sent
  };

  let url: RequestInfo | URL;
  if (typeof input === 'string' && API_ROUTES[input as keyof typeof API_ROUTES]) {
    url = getApiUrl(input as keyof typeof API_ROUTES);
  } else {
    url = input as RequestInfo | URL;
  }

  // Perform the fetch
  let response = await fetch(url, newInit);

  // Handle 401 Unauthorized (reactive refresh)
  if (response.status === 401 && !_retry) {
    const isDebug = typeof process !== 'undefined' && process.env.NODE_ENV !== 'production';
    try {
      if (isDebug) {
        console.warn('[auth/flow] 401 received for API call. Triggering /auth/check...');
      }
      // Check auth state
      const checkResp = await fetch(getApiUrl('AUTH_CHECK'), {
        method: 'GET',
        credentials: 'include' as RequestCredentials,
        headers: { 'X-Client-Platform': 'Web' },
      });
      const checkData = await checkResp.json();
      if (isDebug) {
        console.info('[auth/flow] /auth/check response:', checkData);
      }

      if (checkData.status === 'refresh_required') {
        if (isDebug) {
          console.warn('[auth/flow] refresh_required received. Triggering /auth/refresh...');
        }
        // Try refresh
        const refreshResp = await fetch(getApiUrl('AUTH_REFRESH'), {
          method: 'POST',
          credentials: 'include' as RequestCredentials,
          headers: { 'X-Client-Platform': 'Web' },
        });
        let refreshJson = null;
        try {
          refreshJson = await refreshResp.clone().json();
        } catch { refreshJson = await refreshResp.clone().text(); }
        if (isDebug) {
          console.info('[auth/flow] /auth/refresh response:', refreshJson, { status: refreshResp.status });
        }
        if (refreshResp.ok && refreshJson && refreshJson.status === "Success") {
          if (isDebug) {
            console.info('[auth/flow] Refresh succeeded. Retrying original request...');
          }
          // Try original request again, only once
          const retryResp = await fetchWithHeaders(input, init, true);
          if (isDebug) {
            console.info('[auth/flow] Retried original request after refresh. Status:', retryResp.status);
          }
          return retryResp;
        } else {
          if (isDebug) {
            console.warn('[auth/flow] Refresh failed or did not return Success. User will be logged out.');
          }
          // Refresh failed, signal to logout
          return response;
        }
      } else if (checkData.status === 'login_required') {
        if (isDebug) {
          console.warn('[auth/flow] login_required received from /auth/check. User will be logged out.');
        }
        // Signal logout
        return response;
      }
      // If status is "authenticated", let original 401 stand (unusual)
      if (isDebug) {
        console.warn('[auth/flow] /auth/check returned authenticated after 401, which is unexpected. Returning original response.');
      }
      return response;
    } catch (err) {
      if (isDebug) {
        console.error('[auth/flow] Error during 401 reactive refresh flow:', err);
      }
      // On error, let original 401 stand
      return response;
    }
  }
  return response;
}--- app/lib/ai-models.ts ---
// app/lib/ai-models.ts
export interface AIModelConfig {
  displayName: string;
  model: string;
  provider: string;
  requestPayload: Record<string, any>; // Added for model-specific payloads
  isDefault?: boolean; // Optional: useful for selecting default
  uiOptions?: { // For model-specific UI elements
    thinkingToggleSettings?: {
      enabledBudget: number;
      disabledBudget: number;
    };
  };
}

// Import models from their respective files
// import { azureModels } from './model-list/azure-models'; // Old import
// import { googleModels } from './model-list/google-models'; // Old import
import { cerebrasModels } from './model-list/cerebras-models'; // Keeping this as its structure hasn't changed

// New model imports
import { gemini25FlashPreview0520Model } from './model-list/google/gemini-2.5-flash-preview-05-20';
import { gemini20FlashModel } from './model-list/google/gemini-2.0-flash';
import { gpt41Model } from './model-list/azure/gpt-4.1';
import { API_BASE_URL } from '~/lib/api.config'; // Import API_BASE_URL

// If you add more providers, import them here

// Combine all models into the main AImodels array
export const AImodels: AIModelConfig[] = [
  // ...azureModels, // Old spread
  // ...googleModels, // Old spread
  gpt41Model, // Add new Azure model
  gemini25FlashPreview0520Model, // Add new Google model
  gemini20FlashModel, // Add new Google model
  ...cerebrasModels,
  // Spread other imported model arrays here
  // Add more models here as needed (if they don't fit a provider category or are one-offs)
];

// Select default based on isDefault flag or fallback
// This logic remains the same and works on the combined AImodels array
export const defaultModelConfig: AIModelConfig = AImodels.find(m => m.isDefault) || AImodels[0];

// These constants remain as they are global to the AI service
export const defaultSystemPrompt = "You are a helpful assistant.";

// Use API_BASE_URL to construct these URLs
export const API_STREAM_URL = API_BASE_URL ? `${API_BASE_URL}/api/chat/stream` : "/api/chat/stream";
export const API_HISTORY_URL_BASE = API_BASE_URL ? `${API_BASE_URL}/api/chat` : "/api/chat"; // Note: path adjusted, specific endpoint like /:chatId/history will be appended by calling code--- app/lib/user-cookie-keys.ts ---
// app/lib/user-cookie-keys.ts
// Centralized user-related cookie keys for easy updates
// Naming is now environment-aware.

// Helper to get environment variables, works on client and server.
// Expects VITE_ prefixed keys for client-side access via import.meta.env.
const getEnv = (viteKey: string, defaultValue: string): string => {
  const val = typeof window !== 'undefined'
    ? (import.meta.env as any)[viteKey]    // Client-side (Vite)
    : process.env[viteKey];               // Server-side (Node.js)
  return val || defaultValue;
};

// Define cookie names using environment variables with defaults for production.
// Set these in your .env files (e.g., .env.development, .env.production).
// Example for development (.env.development):
// VITE_AUTH_COOKIE_NAME="dev_krivilak_at"
// VITE_REFRESH_TOKEN_COOKIE_NAME="dev_krivilak_rt"
// VITE_USER_INFO_COOKIE_PREFIX="dev_krivilak_ui_"
//
// Example for production (.env or .env.production):
// VITE_AUTH_COOKIE_NAME="krivilak_at"
// VITE_REFRESH_TOKEN_COOKIE_NAME="krivilak_rt"
// VITE_USER_INFO_COOKIE_PREFIX="krivilak_ui_"

export const KRIVILAK_COOKIE_AT = getEnv("VITE_AUTH_COOKIE_NAME", "krivilak_at");
export const KRIVILAK_COOKIE_RT = getEnv("VITE_REFRESH_TOKEN_COOKIE_NAME", "krivilak_rt");

const USER_INFO_COOKIE_PREFIX = getEnv("VITE_USER_INFO_COOKIE_PREFIX", "krivilak_ui_");

export const KRIVILAK_COOKIE_EMAIL = `${USER_INFO_COOKIE_PREFIX}email`;
export const KRIVILAK_COOKIE_DISPLAYNAME = `${USER_INFO_COOKIE_PREFIX}displayname`;
export const KRIVILAK_COOKIE_FIRSTNAME = `${USER_INFO_COOKIE_PREFIX}firstname`;
export const KRIVILAK_COOKIE_LASTNAME = `${USER_INFO_COOKIE_PREFIX}lastname`;
export const KRIVILAK_COOKIE_PROFILE_PIC_URL = `${USER_INFO_COOKIE_PREFIX}profilepictureurl`;

// For easy iteration/cleanup.
// This array is dynamically populated based on the environment variables.
export const KRIVILAK_USER_COOKIE_NAMES = [
  KRIVILAK_COOKIE_AT,
  KRIVILAK_COOKIE_RT,
  KRIVILAK_COOKIE_EMAIL,
  KRIVILAK_COOKIE_DISPLAYNAME,
  KRIVILAK_COOKIE_FIRSTNAME,
  KRIVILAK_COOKIE_LASTNAME,
  KRIVILAK_COOKIE_PROFILE_PIC_URL,
];--- app/lib/model-list/azure/gpt-4.1.ts ---
import type { AIModelConfig } from '../../ai-models';

export const gpt41Model: AIModelConfig = {
  displayName: "GPT-4.1", // Using the model name as display name, can be changed
  model: "gpt-4.1",
  provider: "azure",
  // isDefault: true, // Set if this should be a default model
  requestPayload: {
    messages: [
      {
        role: "system",
        content: "You are a helpful assistant."
      },
      {
        role: "user",
        content: "" // Placeholder for user content
      }
    ]
    // executionParameters: {} // As per the user's example, though this might be part of a different config
  }
};--- app/lib/model-list/cerebras-models.ts ---
import type { AIModelConfig } from '../ai-models'; // Import the interface

export const cerebrasModels: AIModelConfig[] = [
  {
    displayName: "llama3.1-8b",
    model: "llama3.1-8b",
    provider: "cerebras",
  },
  {
    displayName: "qwen-3-32b",
    model: "qwen-3-32b",
    provider: "cerebras",
  },
];--- app/lib/model-list/google/gemini-2.0-flash.ts ---
import type { AIModelConfig } from '../../ai-models';

export const gemini20FlashModel: AIModelConfig = {
  displayName: "Gemini 2.0 flash",
  model: "gemini-2.0-flash",
  provider: "google",
  // isDefault: false, // Assuming the other one is default
  requestPayload: {
    messages: [
      {
        role: "system",
        content: "You are a helpful assistant."
      },
      {
        role: "user",
        content: "" // Placeholder for user content
      }
    ]
    // Add model-specific generationConfig if different from the other gemini model
    // For example:
    // generationConfig: {
    //   temperature: 0.8
    // }
  }
};--- app/lib/model-list/google/gemini-2.5-flash-preview-05-20.ts ---
import type { AIModelConfig } from '../../ai-models';

export const gemini25FlashPreview0520Model: AIModelConfig = {
  displayName: "Gemini 2.5 flash",
  model: "gemini-2.5-flash-preview-05-20", // Updated model name from example
  provider: "google",
  isDefault: true,
  requestPayload: {
    messages: [
      // Default messages structure, can be overridden
      {
        role: "system",
        content: "You are a helpful assistant."
      },
      {
        role: "user",
        content: "" // Placeholder for user content
      }
    ],
    generationConfig: {
      thinkingConfig: {
        thinkingBudget: 0 // Default to 0, will be controlled by UI toggle
      }
    }
  },
  uiOptions: {
    thinkingToggleSettings: {
      enabledBudget: 24576,
      disabledBudget: 0
    }
  }
};--- app/lib/auth.server.ts ---
// app/lib/auth.server.ts
import { redirect } from "@remix-run/node";
import { getApiUrl, API_ROUTES, fetchWithHeaders } from "./api.config";

// --- Auth Status Types & Helpers ---

// Define a structure for authenticated user details
// Adjust this based on what your /auth/check API returns
export type AuthenticatedUserDetails = {
  id: string;
  name: string;
  email: string;
  avatar_url?: string; // Or 'avatar' if that's the field name
  // any other relevant user fields
};

export type AuthStatus =
  | { status: "authenticated"; reason: "valid_access_token_and_session" | "valid_access_token"; user?: AuthenticatedUserDetails }
  | { status: "login_required"; reason: "session_terminated" | "invalid_or_expired_tokens" | "no_tokens_present" }
  | { status: "refresh_required"; reason: "valid_refresh_token" }
  | { status: "error"; reason?: string };

export function isAuthenticated(auth: AuthStatus): auth is Extract<AuthStatus, { status: "authenticated" }> {
  return auth.status === "authenticated";
}

export function isRefreshable(auth: AuthStatus): auth is Extract<AuthStatus, { status: "refresh_required" }> {
  return auth.status === "refresh_required";
}

// --- Core Auth Functions ---

export async function checkAuth(request: Request): Promise<AuthStatus> {
  try {
    const response = await fetchWithHeaders("AUTH_CHECK", {
      method: "GET",
      headers: {
        cookie: request.headers.get("cookie") ?? "",
      },
      credentials: "include",
    });

    if (!response.ok && response.headers.get("content-type")?.includes("application/json")) {
      const data = await response.json();
      // Check if the error response matches AuthStatus structure for login_required or error
      if (data && data.status && (data.status === "login_required" || data.status === "error" || data.status === "refresh_required") && data.reason) {
        return data as AuthStatus;
      }
      return { status: "login_required", reason: data.message || `API error: ${response.status}` };
    } else if (!response.ok) {
      const errorText = await response.text();
      console.error("Auth check API request failed:", response.status, errorText);
      return { status: "error", reason: `API error: ${response.status}. ${errorText}` };
    }

    const data = await response.json();
    // Accept any valid AuthStatus with status and reason, not just "authenticated"
    if (data && data.status && data.reason) {
      return data as AuthStatus;
    }
    console.error("Auth check API response is not in expected AuthStatus format:", data);
    return { status: "error", reason: "" };
  } catch (error) {
    console.error("Error during checkAuth:", error);
    return { status: "error", reason: "Network error or failed to parse auth/check response" };
  }
}

export async function refreshTokens(request: Request): Promise<{ ok: boolean; setCookieHeaders?: string[] | null }> {
  try {
    const response = await fetchWithHeaders("AUTH_REFRESH", {
      method: "POST",
      headers: {
        cookie: request.headers.get("cookie") ?? "",
        'X-Client-Platform': 'Web', // As per user feedback, ensure this header if backend expects it
      },
      credentials: "include",
    });

    const setCookieHeaders = response.headers.getSetCookie(); // Correct method for Remix/Node.js

    if (!response.ok) {
      const errorBody = await response.text();
      console.warn("Refresh token request failed:", response.status, errorBody);
      // Still return headers, backend might clear cookies on failure
      return { ok: false, setCookieHeaders: setCookieHeaders.length > 0 ? setCookieHeaders : null };
    }

    const data = await response.json();
    // Assuming backend returns a success status or specific message
    if (data.status === "Success" || data.message?.includes("refreshed") || data.ok === true || response.status === 200) {
      return { ok: true, setCookieHeaders };
    } else {
      console.warn("Refresh token API call was not successful according to response body:", data);
      return { ok: false, setCookieHeaders: setCookieHeaders.length > 0 ? setCookieHeaders : null };
    }
  } catch (error) {
    console.error("Error during refreshTokens:", error);
    return { ok: false, setCookieHeaders: null };
  }
}

export async function requireAuth(
  request: Request,
  redirectTo: string = "/login"
): Promise<Extract<AuthStatus, { status: "authenticated" }>> {
  const isDebug = typeof process !== 'undefined' && process.env.NODE_ENV !== 'production';
  const responseHeaders = new Headers(); // To accumulate Set-Cookie headers

  let authStatus = await checkAuth(request);

  if (isDebug) {
    console.info('[requireAuth] Initial /auth/check result:', authStatus);
  }

  if (isRefreshable(authStatus)) {
    if (isDebug) {
      console.warn('[requireAuth] status=refresh_required, attempting refresh...');
    }
    const { ok, setCookieHeaders } = await refreshTokens(request);
    if (isDebug) {
      console.info('[requireAuth] /auth/refresh result:', ok, 'Cookies to set:', setCookieHeaders);
    }

    if (ok && setCookieHeaders && setCookieHeaders.length > 0) {
      setCookieHeaders.forEach(cookie => responseHeaders.append("Set-Cookie", cookie));
      if (isDebug) {
        console.info('[requireAuth] Refresh successful. Redirecting to URL:', request.url, 'with new Set-Cookie headers.');
      }
      // CRITICAL STEP: Redirect to the current URL to apply new cookies.
      throw redirect(request.url, { headers: responseHeaders });
    } else {
      // REFRESH FAILED or no cookies returned:
      if (isDebug) {
        console.warn('[requireAuth] Refresh failed or no new cookies set. Re-checking auth status...');
      }
      // If refresh call itself returned cookies (e.g. to clear them), add them.
      if (setCookieHeaders && setCookieHeaders.length > 0) {
        setCookieHeaders.forEach(cookie => responseHeaders.append("Set-Cookie", cookie));
      }
      authStatus = await checkAuth(request); // Re-check with (likely old) cookies
      if (isDebug) {
        console.info('[requireAuth] /auth/check after failed/no-cookie refresh:', authStatus);
      }
    }
  }

  if (!isAuthenticated(authStatus)) {
    if (isDebug) {
      console.warn('[requireAuth] Not authenticated after all checks. Redirecting to login. Status:', authStatus);
    }
    const currentPath = new URL(request.url).pathname;
    const currentSearch = new URL(request.url).search;
    const nextParam =
      currentPath !== redirectTo && (currentPath !== "/" || currentSearch !== "")
        ? `?next=${encodeURIComponent(currentPath + currentSearch)}`
        : "";
    let reasonParam = "";
    if (authStatus.status === "login_required") { // authStatus.reason is guaranteed by type
      reasonParam = `&error_description=${encodeURIComponent(authStatus.reason)}`;
    } else if (authStatus.status === "error") {
      if (authStatus.reason) {
        reasonParam = `&error_description=${encodeURIComponent(authStatus.reason)}`;
      } else {
        reasonParam = `&error_description=auth_check_error_unknown_reason`;
      }
    } else { // Fallback for any other unauthenticated status not explicitly handled above
      reasonParam = `&error_description=auth_failed_unspecified_reason`;
    }
    
    const finalRedirectTo = `${redirectTo}${nextParam}${nextParam && reasonParam ? reasonParam : !nextParam && reasonParam ? "?" + reasonParam.substring(1) : ""}`;
    
    // Pass any accumulated Set-Cookie headers (e.g., from a failed refresh that clears cookies)
    throw redirect(finalRedirectTo, { headers: responseHeaders });
  }

  if (isDebug) {
    console.info('[requireAuth] Authenticated! User:', authStatus.user);
  }
  // If loader needs to return data with headers: return json({ user: authStatus.user }, { headers: responseHeaders });
  // For now, just return authStatus. If responseHeaders has Set-Cookie from a successful refresh
  // that somehow didn't redirect (which shouldn't happen with the logic above),
  // those cookies won't be applied to the client by returning authStatus directly without headers.
  // The redirect is the primary mechanism.
  return authStatus as Extract<AuthStatus, { status: "authenticated" }>;
}--- app/hooks/useChatSessionMessages.ts ---
// app/hooks/useChatSessionMessages.ts  
import { useState, useEffect } from 'react';  
import { Message } from '~/components/chat/MessageItem';  
  
type ChatLoadingPhase = 'INITIALIZING' | 'PREPARING_CONTENT' | 'READY';  
  
export function useChatSessionMessages({  
  urlChatId,  
  initialMessagesProp,  
  streamChat,  
  location,  
  remixNavigation,  
  navigate,  
  startReactTransition,  
  isNewChatTransitioning,  
  setIsNewChatTransitioning,  
  scrollToBottom,  
}: {  
  urlChatId: string | null;  
  initialMessagesProp: Message[];  
  streamChat: any;  
  location: any;  
  remixNavigation: any;  
  navigate: any;  
  startReactTransition: any;  
  isNewChatTransitioning: boolean;  
  setIsNewChatTransitioning: (v: boolean) => void;  
  scrollToBottom: (behavior: ScrollBehavior) => void;  
}) {  
  const [chatPhase, setChatPhase] = useState<ChatLoadingPhase>('INITIALIZING');  
  const [hasInitialized, setHasInitialized] = useState(false);  
  
  useEffect(() => {  
    if (hasInitialized && remixNavigation.state !== 'idle') return;  
  
    const navState = location.state as { fromNewChatFlow?: boolean; initialMessages?: Message[] } | null;  
  
    if (isNewChatTransitioning && !urlChatId) return; // Corrected: pass as prop  
  
    setChatPhase('INITIALIZING');  
  
    if (urlChatId) {  
      let messagesToUse: Message[] = initialMessagesProp;  
  
      if (  
        streamChat.activeStreamChatId === urlChatId &&  
        streamChat.messages.length > 0 &&  
        initialMessagesProp.length === 0  
      ) {  
        messagesToUse = [...streamChat.messages];  
      }  
      if (navState?.fromNewChatFlow && streamChat.activeStreamChatId === urlChatId) {  
        messagesToUse = [...streamChat.messages];  
      } else if (navState?.fromNewChatFlow && navState.initialMessages) {  
        messagesToUse = navState.initialMessages;  
      } else if (streamChat.currentUIFocusChatId !== urlChatId) {  
        if (!streamChat.isStreaming || streamChat.activeStreamChatId !== urlChatId) {  
          streamChat.clearStreamState();  
        }  
      }  
      streamChat.setMessagesForContext(messagesToUse, urlChatId);  
  
      if (navState?.fromNewChatFlow) {  
        startReactTransition(() => {  
          const { state, ...restOfLocation } = location;  
          const { fromNewChatFlow: _fNCF, initialMessages: _iM, ...newStateWithoutFlow } = (state as any) || {};  
          navigate(restOfLocation, {  
            replace: true,  
            state: Object.keys(newStateWithoutFlow).length > 0 ? newStateWithoutFlow : undefined,  
          });  
        });  
        setIsNewChatTransitioning(false);  
      }  
      setChatPhase('PREPARING_CONTENT');  
    } else if (!urlChatId) {  
      if (  
        streamChat.currentUIFocusChatId !== null ||  
        (streamChat.messages.length > 0 && !streamChat.isStreaming)  
      ) {  
        streamChat.clearStreamState();  
      }  
      setChatPhase('READY');  
    }  
    setHasInitialized(true);  
    // eslint-disable-next-line react-hooks/exhaustive-deps  
  }, [urlChatId, initialMessagesProp, location.pathname, isNewChatTransitioning]);  
  
  useEffect(() => {  
    return () => {  
      setHasInitialized(false);  
    };  
  }, [location.pathname]);  
  
  useEffect(() => {  
    if (  
      chatPhase === 'PREPARING_CONTENT' &&  
      streamChat.currentUIFocusChatId === urlChatId &&  
      urlChatId  
    ) {  
      startReactTransition(() => {  
        setChatPhase('READY');  
        const navState = location.state as { fromNewChatFlow?: boolean } | null;  
        if (!navState?.fromNewChatFlow) {  
          requestAnimationFrame(() => scrollToBottom('auto'));  
        }  
      });  
    }  
  }, [  
    chatPhase,  
    urlChatId,  
    streamChat.currentUIFocusChatId,  
    scrollToBottom,  
    location.state,  
    startReactTransition,  
  ]);  
  
  return {  
    chatPhase,  
    setChatPhase,  
  };  
}  --- app/hooks/useChatSendMessage.ts ---
import { useCallback } from 'react';  
import { v4 as uuidv4 } from 'uuid';  
import { Message } from '~/components/chat/MessageItem';
import type { AIModelConfig } from '~/lib/ai-models';  
  
export function useChatSendMessage({  
  streamChat,  
  urlChatId,  
  lastSelectedModelMapRef,  
  isReactTransitionPending,  
  chatPhase,  
  navigate,  
  startReactTransition,  
  setInput,  
  setIsNewChatTransitioning,  
  chatModelKey  
}: {  
  streamChat: any,  
  urlChatId: string | null,  
  lastSelectedModelMapRef: React.MutableRefObject<{[key: string]: AIModelConfig}>,  
  isReactTransitionPending: boolean,  
  chatPhase: string,  
  navigate: any,  
  startReactTransition: any,  
  setInput: (v: string) => void,  
  setIsNewChatTransitioning: (v: boolean) => void,  
  chatModelKey: string  
}) {  
  return useCallback(
    async (inputTextValue: string, modelConfig: AIModelConfig, options?: { thinkingEnabled?: boolean }) => {
      const trimmedInput = inputTextValue.trim();
      if (!trimmedInput || streamChat.isStreaming || isReactTransitionPending || chatPhase !== 'READY') {
        return;
      }
      setInput('');
      lastSelectedModelMapRef.current[chatModelKey] = modelConfig;
  
      const userMessage: Message = {
        id: crypto.randomUUID(),
        role: 'user',
        content: trimmedInput,
      };
      
      const thinkingEnabled = options?.thinkingEnabled;
  
      if (!urlChatId) {
        const newChatId = uuidv4();
        try {
          setIsNewChatTransitioning(true);
          streamChat.setMessagesForContext([userMessage], newChatId);
          const streamPromise = streamChat.startStream(trimmedInput, modelConfig, newChatId, thinkingEnabled);
          setTimeout(() => {
            const destinationPath = `/chat/${newChatId}`;
            startReactTransition(() => {
              navigate(destinationPath, {
                replace: true,
                state: { initialMessages: [userMessage], fromNewChatFlow: true },
              });
            });
          }, 50);
          await streamPromise;
        } catch (error) {
          console.error('Error in new chat flow:', error);
          setIsNewChatTransitioning(false);
        }
      } else {
        try {
          streamChat.setMessagesForContext([...streamChat.messages, userMessage], urlChatId);
          await streamChat.startStream(trimmedInput, modelConfig, urlChatId, thinkingEnabled);
        } catch (error) {
          console.error('Error in existing chat flow:', error);
        }
      }
    },
    [  
      streamChat,  
      urlChatId,  
      isReactTransitionPending,  
      chatPhase,  
      navigate,  
      startReactTransition,  
      chatModelKey  
    ]  
  );  
}  --- app/hooks/use-mobile.tsx ---
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    // Ensure window is defined (for SSR safety, though matchMedia is client-only)
    if (typeof window === 'undefined') {
      setIsMobile(false); // Default for server or non-browser env
      return;
    }

    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    // Add listener
    mql.addEventListener("change", onChange)
    // Set initial state
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    // Clean up listener
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}--- app/hooks/useSidebarHistoryRefreshOnChatChange.ts ---
import { useEffect, useRef } from 'react';  
  
export function useSidebarHistoryRefreshOnChatChange(initialChatIdFromLoader: string | null, refreshChatHistory: () => void) {  
  const prevChatIdRef = useRef<string | null>(null);  
  
  useEffect(() => {  
    if (  
      prevChatIdRef.current === null && // previously on new chat  
      initialChatIdFromLoader !== null // now on an actual chat  
    ) {  
      refreshChatHistory();  
    }  
    prevChatIdRef.current = initialChatIdFromLoader;  
  }, [initialChatIdFromLoader, refreshChatHistory]);  
}  --- app/hooks/usePerChatModelSelection.ts ---
import { useState, useEffect, useRef } from "react";  
import type { AIModelConfig } from '~/lib/ai-models';  
  
export function usePerChatModelSelection(chatKey: string, defaultModel: AIModelConfig) {  
  const mappingRef = useRef<{ [key: string]: AIModelConfig }>({});  
  const [selectedModel, setSelectedModel] = useState<AIModelConfig>(defaultModel);  
  
  useEffect(() => {  
    setSelectedModel(mappingRef.current[chatKey] ?? defaultModel);  
  }, [chatKey, defaultModel]);  
  
  const handleModelChange = (model: AIModelConfig) => {  
    setSelectedModel(model);  
    mappingRef.current[chatKey] = model;  
  };  
  
  return { selectedModel, handleModelChange };  
}  --- app/hooks/useScrollToBottom.ts ---
// Modified useScrollToBottom.ts hook

import { useRef, useState, useEffect, useCallback } from 'react';
import { Message } from '~/components/chat/MessageItem';

const INTERSECTION_THRESHOLD_PX = 30;
const USER_SCROLL_DEBOUNCE_MS = 150;

export function useScrollToBottom(messages: Message[]) {
  const containerRef = useRef<HTMLDivElement | null>(null);
  const endRef = useRef<HTMLDivElement | null>(null);

  const [isAtBottom, setIsAtBottom] = useState(true);
  const [showScrollDownButton, setShowScrollDownButton] = useState(false);
  const scrollTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const userManuallyScrolled = useRef(false);
  const lastMessageCount = useRef(0);

  // Function to scroll to specific position
  const scrollToPosition = useCallback((position: number, behavior: ScrollBehavior = 'smooth') => {
    const scrollableContainer = containerRef.current;
    if (scrollableContainer) {
      scrollableContainer.scrollTo({
        top: position,
        behavior,
      });
    }
  }, []);

  // Complete scroll to bottom function (unchanged)
  const scrollToBottom = useCallback((behavior: ScrollBehavior = 'smooth') => {
    const scrollableContainer = containerRef.current;
    const bottomMarker = endRef.current;

    if (bottomMarker) {
      bottomMarker.scrollIntoView({ behavior });
    } else if (scrollableContainer) {
      scrollableContainer.scrollTo({
        top: scrollableContainer.scrollHeight,
        behavior,
      });
    }
    setIsAtBottom(true);
    setShowScrollDownButton(false);
  }, []);

  // New function for 30/70 scrolling
  const scrollToPartialView = useCallback((behavior: ScrollBehavior = 'smooth') => {
    const scrollableContainer = containerRef.current;
    if (!scrollableContainer || userManuallyScrolled.current) return;

    // Calculate the position that shows 30% previous content, 70% new content
    const containerHeight = scrollableContainer.clientHeight;
    const scrollHeight = scrollableContainer.scrollHeight;
    
    // Position to show 30% of previous content at the top
    // This means we want to position the scroll so that we're 70% down the way
    // from (scrollHeight - containerHeight) which is the maximum scroll position
    const newPosition = Math.max(
      0,
      (scrollHeight - containerHeight) * 0.7
    );
    
    scrollToPosition(newPosition, behavior);
  }, [scrollToPosition]);

  // Track user manual scrolling
  useEffect(() => {
    const scrollableContainer = containerRef.current;
    if (!scrollableContainer) return;

    const handleScroll = () => {
      // Consider any scroll during active interaction as manual
      userManuallyScrolled.current = true;
      
      if (scrollTimeoutRef.current) clearTimeout(scrollTimeoutRef.current);

      scrollTimeoutRef.current = setTimeout(() => {
        if (scrollableContainer) {
          const { scrollTop, scrollHeight, clientHeight } = scrollableContainer;
          const isNearBottom = scrollHeight - scrollTop - clientHeight < INTERSECTION_THRESHOLD_PX + 5;

          if (!isNearBottom) {
            if (!showScrollDownButton) setShowScrollDownButton(true);
            if (isAtBottom) setIsAtBottom(false);
          } else {
            if (showScrollDownButton) setShowScrollDownButton(false);
            if (!isAtBottom) setIsAtBottom(true);
            // Reset manual scroll flag when user scrolls back to bottom
            userManuallyScrolled.current = false;
          }
        }
      }, USER_SCROLL_DEBOUNCE_MS);
    };

    scrollableContainer.addEventListener('scroll', handleScroll, { passive: true });
    return () => {
      scrollableContainer.removeEventListener('scroll', handleScroll);
      if (scrollTimeoutRef.current) clearTimeout(scrollTimeoutRef.current);
    };
  }, [isAtBottom, showScrollDownButton]);

  // Handle new messages logic
  useEffect(() => {
    // Reset manual scroll flag on first render
    if (messages.length === 0) {
      userManuallyScrolled.current = false;
    }
    
    // If new message was added
    if (messages.length > lastMessageCount.current) {
      // If this is a user message, apply the partial view scroll
      const lastMessage = messages[messages.length - 1];
      
      // When a new user message is sent, do partial scroll
      if (lastMessage && lastMessage.role === 'user') {
        // Short delay to allow DOM to update
        setTimeout(() => scrollToPartialView(), 50);
      } 
      // When receiving AI response and user hasn't manually scrolled
      else if (lastMessage && lastMessage.role === 'assistant' && !userManuallyScrolled.current) {
        // If at bottom or was already showing partial view, maintain position
        if (isAtBottom) {
          setTimeout(() => scrollToBottom('auto'), 10);
        }
      }
      
      lastMessageCount.current = messages.length;
    }
  }, [messages, isAtBottom, scrollToBottom, scrollToPartialView]);

  // Observer to track if we're at bottom (unchanged)
  useEffect(() => {
    const scrollableContainer = containerRef.current;
    const bottomMarker = endRef.current;

    if (!scrollableContainer || !bottomMarker) {
      setIsAtBottom(true);
      setShowScrollDownButton(false);
      return;
    }

    const observer = new IntersectionObserver(
      ([entry]) => {
        const isCurrentlyIntersecting = entry.isIntersecting;
        setIsAtBottom(isCurrentlyIntersecting);
        setShowScrollDownButton(!isCurrentlyIntersecting);
      },
      {
        root: scrollableContainer,
        rootMargin: `0px 0px ${INTERSECTION_THRESHOLD_PX}px 0px`,
        threshold: 0.01,
      }
    );
    observer.observe(bottomMarker);

    if (
      scrollableContainer.scrollHeight > scrollableContainer.clientHeight &&
      scrollableContainer.scrollTop + scrollableContainer.clientHeight < scrollableContainer.scrollHeight - INTERSECTION_THRESHOLD_PX
    ) {
      setIsAtBottom(false);
      setShowScrollDownButton(true);
    } else {
      setIsAtBottom(true);
      setShowScrollDownButton(false);
    }

    return () => {
      observer.unobserve(bottomMarker);
      observer.disconnect();
    };
  }, [containerRef, endRef]);

  // Reset userManuallyScrolled flag when we navigate to a new chat
  const resetManualScrollFlag = useCallback(() => {
    userManuallyScrolled.current = false;
  }, []);

  return {
    containerRef,
    endRef,
    isAtBottom,
    showScrollDownButton,
    scrollToBottom,
    scrollToPartialView,
    resetManualScrollFlag
  };
}--- app/root.tsx ---
import {
  Links,
  Meta,
  Outlet,
  Scripts,
  ScrollRestoration,
} from "@remix-run/react";
import type { LinksFunction } from "@remix-run/node"; // No loader needed here if __app.tsx handles auth

import "./tailwind.css";

export const links: LinksFunction = () => [  
  { rel: "preconnect", href: "https://fonts.googleapis.com" },  
  { rel: "preconnect", href: "https://fonts.gstatic.com", crossOrigin: "anonymous" },  
  {  
    rel: "stylesheet",  
    href:  
      "https://fonts.googleapis.com/css2?" +  
      "family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&" +  
      "family=Source+Serif+4:ital@0;1&" +  
      "family=JetBrains+Mono:wght@400;700&" +  
      "display=swap",  
  },  
];  

export function Layout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <Meta />
        <Links />
      </head>
      <body>
        {children}
        <ScrollRestoration />
        <Scripts />
      </body>
    </html>
  );
}

export default function App() {
  // This Outlet will render __app.tsx (for protected routes) or login.tsx, etc.
  return <Outlet />;
}--- app/routes/__app.tsx ---
// app/routes/__app.tsx
import type { LoaderFunctionArgs, MetaFunction } from "@remix-run/node";
import { json } from "@remix-run/node";
import { Outlet, useLoaderData } from "@remix-run/react";

import { requireAuth, type AuthenticatedUserDetails } from "~/lib/auth.server";
import { AppSidebar } from "~/components/app-sidebar";
import { SidebarProvider, SidebarInset, SidebarTrigger } from "~/components/ui/sidebar";
import type { NavItem } from "~/components/sidebar-nav";
import { Separator } from "~/components/ui/separator";
import { StreamingChatProvider } from "~/components/chat/streaming-chat-context";
import { SidebarChatHistoryProvider } from "~/components/sidebar-chat-history-context";
// ADD THIS IMPORT

export interface AppLoaderData {
  user: AuthenticatedUserDetails;
  appName: string;
  mainNavItems: NavItem[];
}

export async function loader({ request }: LoaderFunctionArgs) {
  await requireAuth(request);
  return json<AppLoaderData>({
    user: {
      id: "dummy",
      name: "Dummy",
      email: "dummy@example.com",
      avatar_url: "/avatars/default.png",
    },
    appName: "Krivi AI",
    mainNavItems: [],
  });
}

export const meta: MetaFunction = () => [  
  { title: "Krivi AI | Ignite & Flow" }  
];  

export default function AppLayout() {
  const { user, appName, mainNavItems } = useLoaderData<typeof loader>();
  const sidebarUser = {
    name: user.name,
    email: user.email,
    avatar: "/avatars/default.png",
  };

  return (
    // WRAP THE ENTIRE SIDEBAR PROVIDER (OR JUST THE OUTLET PART IF SIDEBAR IS NOT CHAT RELATED)
    // WITH STREAMINGCHATPROVIDER. For chat apps, often the whole app structure is relevant.
    <SidebarChatHistoryProvider>
      <StreamingChatProvider>
        <SidebarProvider>
          <AppSidebar
            user={sidebarUser}
            appName={appName}
            mainNav={mainNavItems}
          />
          <SidebarInset>
            <div className="relative flex flex-col h-[100dvh] min-h-0 w-full">
              <header
                className="  
                sticky top-0 left-0 right-0 z-30 flex  
                h-[41px] md:h-[62px]  
                shrink-0 items-center gap-2 border-b border-border bg-background  
              "
              >
                <div className="flex items-center gap-2 px-4">
                  <SidebarTrigger className="-ml-1" />
                  <Separator orientation="vertical" className="mr-2 h-4 bg-border" />
                </div>
              </header>
              <main className="relative flex-1 min-h-0 w-full flex flex-col">
                {/* Outlet is where your /chat and /chat/:id routes render */}
                <Outlet />
              </main>
            </div>
          </SidebarInset>
        </SidebarProvider>
      </StreamingChatProvider>
    </SidebarChatHistoryProvider>
  );
}--- app/routes/__app.chat.$chatId.tsx ---
// app/routes/__app.chat.$chatId.tsx
import { useLoaderData, useLocation, useParams } from "@remix-run/react";
import { requireAuth } from "~/lib/auth.server";
import { ChatPageLayout } from "~/components/chat/ChatPageLayout";
import type { Message } from "~/components/chat/MessageItem";
import { fetchWithHeaders, getApiUrl } from "~/lib/api.config"; // Import getApiUrl
import { json, LoaderFunctionArgs } from "@remix-run/node";


interface LoaderData {
  chatId: string;
  initialMessages: Message[];
  error?: string;
}

export async function loader({ request, params }: LoaderFunctionArgs): Promise<ReturnType<typeof json<LoaderData>>> {
  await requireAuth(request);
  const chatId = params.chatId;

  if (!chatId) {
    throw new Response("Chat ID missing in params", { status: 404 });
  }

  let messagesFromHistory: Message[] = [];
  // Construct URL using getApiUrl and append dynamic parts
  const baseHistoryUrl = getApiUrl('CHAT_HISTORY_BASE');
  const historyUrl = `${baseHistoryUrl.replace(/\/$/, '')}/${chatId}/history?limit=50`;

  try {
    const response = await fetchWithHeaders(historyUrl, {
      method: 'GET',
      headers: { 'Cookie': request.headers.get('Cookie') || '' },
    });

    if (response.ok) {
      const data = await response.json();
      if (data.messages && Array.isArray(data.messages)) {
        messagesFromHistory = data.messages.map((msg: any) => ({
          id: msg.id || crypto.randomUUID(), 
          role: msg.role, 
          content: msg.content, 
          timestamp: msg.createdAt || msg.timestamp ? new Date(msg.createdAt || msg.timestamp).getTime() : undefined,
        }));
      }
    } else {
      console.error(`Failed to fetch chat history for ${chatId}: ${response.status} ${response.statusText}`);
      return json({ chatId, initialMessages: [], error: `Failed to load history: ${response.status}` });
    }
  } catch (error: any) {
    console.error(`Error fetching chat history for ${chatId}:`, error);
    return json({ chatId, initialMessages: [], error: `Error loading chat: ${error.message}` });
  }
  return json({ chatId, initialMessages: messagesFromHistory });
}


export default function ChatWithIdPage() {
  const loaderData = useLoaderData<LoaderData>();
  const location = useLocation();
  const params = useParams(); // Use params for the key and current ID

  const navState = location.state as { initialMessages?: Message[], fromNewChatFlow?: boolean } | null;
  
  // Default to loader data. ChatPageLayout will further refine based on context and navState.
  let finalInitialMessages = loaderData.initialMessages;

  // This logic is simplified because ChatPageLayout's Effect 1 now has more robust handling
  // of messages from navState vs. loaderData vs. existing context state.
  if (navState?.fromNewChatFlow && navState.initialMessages && params.chatId === loaderData.chatId) {
      // We can still prefer navState messages if it's an immediate navigation
      // and ChatPageLayout will reconcile with context.
      finalInitialMessages = navState.initialMessages;
  }
  
  if (loaderData.error) {
    console.error("Error in loader for ChatWithIdPage:", loaderData.error);
  }

  return (
    <ChatPageLayout
      key={params.chatId} 
      initialChatIdFromLoader={loaderData.chatId} // Pass loader's chatId
      initialMessagesProp={finalInitialMessages}
    />
  );
}--- app/routes/login.tsx ---
// app/routes/login.tsx
import type { LoaderFunctionArgs, MetaFunction } from "@remix-run/node";
import { json, redirect } from "@remix-run/node";
import { useLoaderData, useSearchParams } from "@remix-run/react";
import { FaGoogle } from "react-icons/fa";

import { Button } from "~/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "~/components/ui/card";
import {
  checkAuth,
  refreshTokens,
  isAuthenticated,
  isRefreshable,
  type AuthStatus, // Type import is fine from .server files
} from "~/lib/auth.server";
import { getApiUrl } from "~/lib/api.config"; // Import getApiUrl from client-safe config
import { useIsMobile } from "~/hooks/use-mobile";

export const meta: MetaFunction = () => {
  return [{ title: "Sign In" }];
};

export async function loader({ request }: LoaderFunctionArgs) {
  const url = new URL(request.url);
  const responseHeaders = new Headers();

  let authStatus = await checkAuth(request);

  if (isRefreshable(authStatus)) {
    console.log("[Login Loader] Token refresh required. Attempting refresh...");
    const { ok, setCookieHeader } = await refreshTokens(request);
    if (ok && setCookieHeader) {
      responseHeaders.append("Set-Cookie", setCookieHeader);
      const destination = url.pathname + url.search;
      console.log(`[Login Loader] Refresh successful. Redirecting to ${destination} to apply new cookies.`);
      throw redirect(destination, { headers: responseHeaders });
    }
    authStatus = await checkAuth(request); // Re-check auth after failed refresh
    console.log("[Login Loader] Refresh failed or no cookies set. New auth status:", authStatus.status);
  }

  if (isAuthenticated(authStatus)) {
    const next = url.searchParams.get("next") || "/"; // Default to app's root
    console.log(`[Login Loader] User already authenticated. Redirecting to: ${next}`);
    throw redirect(next, { headers: responseHeaders });
  }

  return json({ authStatus }, { headers: responseHeaders });
}

export default function LoginPage() {  
  const { authStatus } = useLoaderData<typeof loader>();  
  const [searchParams] = useSearchParams();  
  const isMobile = useIsMobile();  
  
  const googleLoginUrl = getApiUrl("GOOGLE_LOGIN");  
  const nextParam = searchParams.get("next");  
  const finalGoogleLoginUrl = nextParam  
    ? `${googleLoginUrl}?final_redirect_path=${encodeURIComponent(nextParam)}`  
    : googleLoginUrl;  
  
  // Define only the errors we want to show to the user for login-specific issues
  const LOGIN_SPECIFIC_ERROR_MESSAGES: Record<string, string> = {
    session_terminated: "Your session has been terminated. Please sign in again.",
    invalid_or_expired_tokens: "Your session is invalid or has expired. Please sign in again.",
    // Add any other specific login-related errors that should be user-visible here.
    // For example, if your backend can return "invalid_credentials":
    // "invalid_credentials": "The username or password you entered is incorrect.",
  };

  const displayMessage = searchParams.get("message"); // For general messages, not errors
  let determinedErrorKey: string | null | undefined = searchParams.get("error_description") || searchParams.get("error");

  // If no error key from URL params, try to get it from authStatus
  if (!determinedErrorKey && authStatus) {
    // Only consider 'login_required' or 'error' statuses for deriving an error key from authStatus.reason
    if (authStatus.status === "login_required" || authStatus.status === "error") {
      determinedErrorKey = authStatus.reason; // authStatus.reason might be undefined or a non-displayable code
    }
  }

  // Map the determinedErrorKey to a user-friendly message if it's a known login-specific error
  // Otherwise, errorReason will be an empty string, suppressing generic/unknown errors.
  const errorReason = determinedErrorKey ? (LOGIN_SPECIFIC_ERROR_MESSAGES[determinedErrorKey] ?? "") : "";
  
  return (  
    <div className="flex min-h-screen items-center justify-center bg-background px-4 py-12">  
      <Card className="w-full max-w-md shadow-xl">  
        <CardHeader className="text-center">  
          <CardTitle className="text-3xl font-bold tracking-tight text-primary">  
            Access Your Account  
          </CardTitle>  
          <CardDescription className="text-muted-foreground pt-2">  
            Continue with Google to securely sign in.  
          </CardDescription>  
        </CardHeader>  
        <CardContent className="space-y-6 pt-6">  
          {errorReason && (  
            <div className="rounded-md border border-destructive/50 bg-destructive/10 p-3 text-center text-sm text-destructive">  
              <p>{errorReason}</p>  
            </div>  
          )}  
          {displayMessage && !errorReason && (  
            <div className="rounded-md border border-primary/50 bg-primary/10 p-3 text-center text-sm text-primary">  
              <p>{displayMessage}</p>  
            </div>  
          )}  
          <Button  
            asChild  
            size={isMobile ? "lg" : "lg"}  
            className="w-full bg-primary text-primary-foreground hover:bg-primary/90 text-lg py-6"  
          >  
            <a href={finalGoogleLoginUrl} className="flex items-center justify-center gap-3">  
              <FaGoogle className="h-5 w-5" />  
              Sign in with Google  
            </a>  
          </Button>  
        </CardContent>  
        <CardFooter className="flex-col items-center text-center pt-6">  
          <p className="text-xs text-muted-foreground">  
            By proceeding, you agree to our Terms of Service and Privacy Policy.  
          </p>  
        </CardFooter>  
      </Card>  
    </div>  
  );  
}  --- app/routes/__app._index.tsx ---
// app/routes/__app._index.tsx
import { json, LoaderFunctionArgs, MetaFunction } from "@remix-run/node";
import { useLoaderData } from "@remix-run/react";
import { ChatPageLayout } from "~/components/chat/ChatPageLayout";
import { requireAuth } from "~/lib/auth.server";
import type { Message } from "~/components/chat/MessageItem";

export const meta: MetaFunction = () => [{ title: "Krivi AI" }];  


export async function loader({ request }: LoaderFunctionArgs) {
  await requireAuth(request);
  return json({
    initialChatId: null,
    initialMessages: [],
  });
}

export default function AppRootNewChatPage() {
  const { initialChatId, initialMessages } = useLoaderData<{
    initialChatId: null;
    initialMessages: Message[];
  }>();

  return (
    <ChatPageLayout
      key="new-chat-page" // Stable key for the new chat page instance
      initialChatIdFromLoader={initialChatId}
      initialMessagesProp={initialMessages}
    />
  );
}--- app/entry.client.tsx ---
/**
 * By default, Remix will handle hydrating your app on the client for you.
 * You are free to delete this file if you'd like to, but if you ever want it revealed again, you can run `npx remix reveal` ✨
 * For more information, see https://remix.run/file-conventions/entry.client
 */

import { RemixBrowser } from "@remix-run/react";
import { startTransition, StrictMode } from "react";
import { hydrateRoot } from "react-dom/client";

startTransition(() => {
  hydrateRoot(
    document,
    <StrictMode>
      <RemixBrowser />
    </StrictMode>
  );
});
--- app/components/sidebar-nav.tsx ---
import * as React from "react";
import { Link, useNavigate } from "@remix-run/react";
import { ChevronRight, type LucideIcon as LucideIconType } from "lucide-react";
import { Collapsible, CollapsibleContent, CollapsibleTrigger } from "~/components/ui/collapsible";
import { Button } from "~/components/ui/button";
import { Separator } from "~/components/ui/separator";
import { cn } from "~/lib/utils";
import { getApiUrl, fetchWithHeaders } from "~/lib/api.config";
import { useSidebar } from "./ui/sidebar";
import { useSidebarChatHistory } from "./sidebar-chat-history-context";

type LucideIcon = LucideIconType;

export interface NavSubItem {
  id: string;
  title: string;
  href: string;
  isActive?: boolean;
}

export interface NavItem {
  id: string;
  title: string;
  href?: string;
  icon?: LucideIcon;
  isActive?: boolean;
  subItems?: NavSubItem[]; // could be NavItem[] but keep as is for simplicity  
  isGroupLabel?: boolean;
}

interface SidebarNavProps {
  mainNav: NavItem[];
}

interface ApiChatSession {
  ChatId: string;
  Title: string;
  CreatedAt: string;
  LastMessageAt: string;
}

// --- Utility ---  
const getStartOfDay = (date: Date): Date => {
  const d = new Date(date);
  d.setHours(0, 0, 0, 0);
  return d;
};

const processChatHistoryToNavItems = (chatSessions: ApiChatSession[]): NavItem[] => {
  const navItems: NavItem[] = [];
  if (!Array.isArray(chatSessions) || chatSessions.length === 0) return navItems;

  const now = new Date();
  const todayStart = getStartOfDay(now);
  const yesterdayStart = new Date(todayStart);
  yesterdayStart.setDate(todayStart.getDate() - 1);
  const sevenDaysAgoStart = new Date(todayStart);
  sevenDaysAgoStart.setDate(todayStart.getDate() - 7);
  const thirtyDaysAgoStart = new Date(todayStart);
  thirtyDaysAgoStart.setDate(todayStart.getDate() - 30);

  const sections: { [key: string]: ApiChatSession[] } = {
    today: [],
    yesterday: [],
    prev7Days: [],
    prev30Days: [],
  };
  chatSessions.sort((a, b) => new Date(b.LastMessageAt).getTime() - new Date(a.LastMessageAt).getTime());

  chatSessions.forEach(session => {
    const sessionDate = new Date(session.LastMessageAt);
    if (sessionDate >= todayStart)
      sections.today.push(session);
    else if (sessionDate >= yesterdayStart)
      sections.yesterday.push(session);
    else if (sessionDate >= sevenDaysAgoStart)
      sections.prev7Days.push(session);
    else if (sessionDate >= thirtyDaysAgoStart)
      sections.prev30Days.push(session);
  });

  const createChatNavItem = (session: ApiChatSession): NavItem => ({
    id: `chat-${session.ChatId}`,
    title: session.Title.length > 30 ? session.Title.substring(0, 27) + "..." : session.Title,
    href: `/chat/${session.ChatId}`,
  });

  if (sections.today.length > 0) {
    navItems.push({ id: 'ch-label-today', title: 'Today', isGroupLabel: true });
    sections.today.forEach(s => navItems.push(createChatNavItem(s)));
  }
  if (sections.yesterday.length > 0) {
    navItems.push({ id: 'ch-label-yesterday', title: 'Yesterday', isGroupLabel: true });
    sections.yesterday.forEach(s => navItems.push(createChatNavItem(s)));
  }
  if (sections.prev7Days.length > 0) {
    navItems.push({ id: 'ch-label-prev7', title: 'Previous 7 days', isGroupLabel: true });
    sections.prev7Days.forEach(s => navItems.push(createChatNavItem(s)));
  }
  if (sections.prev30Days.length > 0) {
    navItems.push({ id: 'ch-label-prev30', title: 'Previous 30 days', isGroupLabel: true });
    sections.prev30Days.forEach(s => navItems.push(createChatNavItem(s)));
  }

  return navItems;
};

// --- NavItemDisplay ---  
/**  
 * For simple links (no sub-items), we disable prefetch for chat history entries (and all simple links by default).  
 * If you have other simple sidebar links you want to keep prefetch="intent", adjust the condition!  
 */
const NavItemDisplay: React.FC<{ item: NavItem; isSubItem?: boolean }> = ({ item, isSubItem = false }) => {
  const [isOpen, setIsOpen] = React.useState(item.isActive ?? false);
  const { isMobile, setOpenMobile } = useSidebar(); // 👈 add this  

  if (item.isGroupLabel) {
    return (
      <div className="px-3 pt-4 pb-1.5 text-[0.8125rem] font-semibold text-sidebar-foreground">
        {item.title}
      </div>
    );
  }

  const commonButtonClasses = cn(
    "w-full justify-start items-center gap-2.5 h-auto px-3 py-1.5 text-[0.8125rem] font-medium",
    isSubItem && "pl-9 pr-3 py-1.5 text-xs",
    item.isActive
      ? "bg-sidebar-accent text-sidebar-accent-foreground"
      : "text-sidebar-foreground/80 hover:bg-sidebar-accent/60 hover:text-sidebar-accent-foreground",
    "transition-colors rounded-md"
  );

  // --- SIMPLE LINK (no subItems): always prefetch="none" for chat history ---  
  if (!item.subItems || item.subItems.length === 0) {
    return (
      <Button
        variant="ghost"
        asChild
        className={commonButtonClasses}
        title={item.title}
      >
        <Link
          to={item.href || "#"}
          prefetch="none"
          onClick={() => {
            if (isMobile) setOpenMobile(false); // 👈 Only close when mobile  
          }}
        >
          {item.icon && (
            <item.icon className={cn("size-4 shrink-0", isSubItem && "size-3.5")} />
          )}
          <span className="truncate flex-1">{item.title}</span>
        </Link>
      </Button>
    );
  }

  // ---- COLLAPSIBLE GROUP (could have its head as link) ----  
  return (
    <Collapsible open={isOpen} onOpenChange={setIsOpen} className="w-full">
      <div className="flex items-center">
        <Button
          variant="ghost"
          asChild={!!item.href}
          className={cn(commonButtonClasses, "flex-1")}
          title={item.title}
          onClick={!item.href ? (e) => { e.preventDefault(); setIsOpen(!isOpen); } : undefined}
        >
          {item.href ? (
            <Link
              to={item.href}
              prefetch="none" // For collapsible main link, also prevent prefetch  
              onClick={(e) => {
                if (item.subItems && item.subItems.length > 0) {
                  e.preventDefault();
                  setIsOpen(!isOpen);
                }
                // else allow navigation  
              }}
            >
              {item.icon && <item.icon className="size-4 shrink-0" />}
              <span className="truncate flex-1">{item.title}</span>
            </Link>
          ) : (
            <>
              {item.icon && <item.icon className="size-4 shrink-0" />}
              <span className="truncate flex-1">{item.title}</span>
            </>
          )}
        </Button>
        <CollapsibleTrigger asChild>
          <Button variant="ghost" size="icon" className="ml-1 size-7 shrink-0">
            <ChevronRight className={cn("size-3.5 transition-transform text-sidebar-foreground/60", isOpen && "rotate-90")} />
            <span className="sr-only">Toggle {item.title}</span>
          </Button>
        </CollapsibleTrigger>
      </div>
      <CollapsibleContent className="pl-3.5 mt-0.5 space-y-0.5">
        {/* Apply the same rule recursively to sub-items: prefetch="none" */}
        {item.subItems.map((subItem) => (
          <NavItemDisplay
            key={subItem.id}
            // If your subItems are not NavItem, but NavSubItem, convert accordingly:  
            item={{ ...subItem, icon: (subItem as any).icon || undefined }}
            isSubItem
          />
        ))}
      </CollapsibleContent>
    </Collapsible>
  );
};
// ----------- MAIN SIDEBARNAV COMPONENT -----------  
export function SidebarNav({ mainNav }: SidebarNavProps) {
  const [chatHistoryNavItems, setChatHistoryNavItems] = React.useState<NavItem[]>([]);
  const [isLoadingHistory, setIsLoadingHistory] = React.useState(true);
  const [errorHistory, setErrorHistory] = React.useState<string | null>(null);
  const { lastRefreshTimestamp } = useSidebarChatHistory();

  const refreshChatHistory = React.useCallback(async () => {
    setIsLoadingHistory(true);
    setErrorHistory(null);
    try {
      // const apiUrl = getApiUrl("CHAT_SESSION_LIST"); // No longer needed
      const response = await fetchWithHeaders("CHAT_SESSION_LIST", {
        credentials: "include",
        headers: { "Accept": "application/json" }
      });
      if (!response.ok) {
        let errorData = `API Error: ${response.status} ${response.statusText}`;
        try {
          if (response.headers.get("content-type")?.includes("application/json")) {
            const jsonData = await response.json();
            errorData = jsonData.message || JSON.stringify(jsonData);
          } else {
            errorData = await response.text();
          }
        } catch (parseErr) { /* ignore, use statusText */ }
        throw new Error(errorData);
      }
      const data: ApiChatSession[] = await response.json();
      const processedNavItems = processChatHistoryToNavItems(data);
      setChatHistoryNavItems(processedNavItems);
    } catch (err) {
      console.error("[SidebarNav] Failed to fetch/process chat history:", err);
      setErrorHistory(err instanceof Error ? err.message : "An unknown error occurred.");
      setChatHistoryNavItems([]);
    } finally {
      setIsLoadingHistory(false);
    }
  }, []);

  React.useEffect(() => { refreshChatHistory(); }, [refreshChatHistory,lastRefreshTimestamp]);

  return (
    <div className="flex flex-col h-full p-2 space-y-1">
      {mainNav.length > 0 && (
        <nav className="space-y-0.5">
          {mainNav.map((item) => <NavItemDisplay key={item.id} item={item} />)}
        </nav>
      )}

      {(mainNav.length > 0 && (isLoadingHistory || chatHistoryNavItems.length > 0 || errorHistory)) && (
        <Separator className="my-2 bg-border/60" />
      )}

      <div className="px-1 pt-1 pb-1 text-base font-semibold text-sidebar-foreground">
        Chat History
      </div>

      <div className="flex-1 overflow-y-auto space-y-0.5 pr-1 custom-scrollbar">
        {isLoadingHistory ? (
          <div className="px-3 py-2 text-sm text-sidebar-foreground/70 text-center">
            Loading history…
          </div>
        ) : errorHistory ? (
          <div className="px-3 py-2 text-sm text-destructive text-center break-words">
            Error: {errorHistory.substring(0, 150)}{errorHistory.length > 150 && "..."}
            <Button variant="link" size="sm" onClick={refreshChatHistory} className="mt-1">
              Try again
            </Button>
          </div>
        ) : chatHistoryNavItems.length > 0 ? (
          chatHistoryNavItems.map((item) => <NavItemDisplay key={item.id} item={item} />)
        ) : (
          <div className="px-3 py-2 text-xs text-sidebar-foreground/60 italic">
            No chat history found.
          </div>
        )}
      </div>
    </div>
  );
}  --- app/components/Markdown.tsx ---
import React, { useState } from "react";  
import ReactMarkdown from "react-markdown";  
import type { Components } from "react-markdown";  
import remarkGfm from "remark-gfm";  
import rehypeHighlight from "rehype-highlight";  
import { FiCopy, FiCheck } from "react-icons/fi";  
import "highlight.js/styles/atom-one-dark.css";  
import type {  
  Element as ProjectHastElement,  
  ElementContent as ProjectHastElementContent,  
} from "hast";  
  
// Utility to robustly extract text content (for copy)  
const extractText = (nodes?: ProjectHastElementContent[]): string =>  
  !nodes  
    ? ""  
    : nodes  
        .map((node) => {  
          if (node.type === "text") {  
            return node.value || "";  
          }  
          if (node.type === "element" && node.children) {  
            return extractText(node.children as ProjectHastElementContent[]);  
          }  
          return "";  
        })  
        .join("");  
  
// Props for the Markdown component  
interface MarkdownProps {  
  children: string;  
  className?: string;  
}  
  
// Define the props for the custom code component  
type CustomCodeRendererProps = React.DetailedHTMLProps<  
  React.HTMLAttributes<HTMLElement>,  
  HTMLElement  
> & {  
  inline?: boolean;  
  node?: ProjectHastElement;  
};  
  
const CustomCodeRenderer: React.FC<CustomCodeRendererProps> = ({  
  node,  
  inline,  
  className,  
  children,  
  ...props  
}) => {  
  const match = /language-(\w+)/.exec(className || "");  
  const language = match ? match[1] : "plaintext";  
  
  const contentString = React.Children.toArray(children)  
    .map((child) =>  
      typeof child === "string" || typeof child === "number"  
        ? child.toString()  
        : ""  
    )  
    .join("");  
  
  const [copied, setCopied] = useState(false);  
  
  if (inline) {  
    // Only <code> for inline code, no <figure>  
    return (  
      <code  
        className="px-1 py-0.5 rounded bg-muted font-mono text-sm"  
        {...props}  
      >  
        {children}  
      </code>  
    );  
  }  
  
  // For code blocks: wrap in <figure> (correct usage)  
  return (  
    <figure className="relative rounded-lg overflow-hidden shadow-sm my-4 border border-border bg-card/50 dark:bg-zinc-900/50 w-full">  
      {/* Code Header */}  
      <figcaption className="bg-muted/70 dark:bg-zinc-800/70 text-muted-foreground py-1.5 px-4 font-mono text-xs flex items-center justify-between border-b border-border">  
        <span className="uppercase tracking-wider">{language}</span>  
        <button  
          className="bg-secondary hover:bg-secondary/80 text-secondary-foreground rounded px-2 py-0.5 text-xs flex items-center gap-1 border border-transparent hover:border-border"  
          onClick={() => {  
            navigator.clipboard  
              .writeText(contentString.trim())  
              .then(() => {  
                setCopied(true);  
                setTimeout(() => setCopied(false), 1500);  
              })  
              .catch((err) => console.error("Failed to copy:", err));  
          }}  
          type="button"  
          aria-label="Copy code to clipboard"  
        >  
          {copied ? (  
            <FiCheck size={14} className="text-green-500" />  
          ) : (  
            <FiCopy size={14} />  
          )}  
        </button>  
      </figcaption>  
      <pre  
        className="p-4 text-sm font-mono text-foreground overflow-x-auto w-full"  
        style={{  
          margin: 0,  
          tabSize: 2,  
        }}  
      >  
        <code className={className || ""} {...props}>  
          {children}  
        </code>  
      </pre>  
    </figure>  
  );  
};  
  
// Custom markdown components overriding ReactMarkdown defaults  
const markdownComponents: Components = {  
  p: (props) => (  
    <p  
      className="my-3 leading-relaxed text-base w-full break-words"  
      {...props}  
    />  
  ),  
  code: CustomCodeRenderer, // main custom block handler  
  
  // removed `pre: ...` mapping (no longer needed!)  
  
  table: (props) => (  
    <div className="my-4 overflow-x-auto border border-border rounded-md w-full">  
      <table className="min-w-full divide-y divide-border" {...props} />  
    </div>  
  ),  
  tr: (props) => (  
    <tr  
      className="hover:bg-muted/30 dark:hover:bg-zinc-700/30 transition-colors"  
      {...props}  
    />  
  ),  
  th: (props) => (  
    <th  
      className="px-4 py-2.5 text-left text-xs font-medium text-muted-foreground uppercase tracking-wider"  
      {...props}  
    />  
  ),  
  td: (props) => (  
    <td  
      className="px-4 py-2.5 text-sm text-foreground break-words"  
      {...props}  
    />  
  ),  
  img: (props) => (  
    <img  
      className="max-w-full h-auto rounded-md my-4"  
      {...props}  
      alt={props.alt || "Image"}  
    />  
  ),  
  blockquote: (props) => (  
    <blockquote  
      className="border-l-4 border-muted pl-4 italic my-4 text-muted-foreground"  
      {...props}  
    />  
  ),  
  ul: (props) => <ul className="list-disc pl-6 my-4 space-y-2" {...props} />,  
  ol: (props) => <ol className="list-decimal pl-6 my-4 space-y-2" {...props} />,  
  li: (props) => <li className="mb-1" {...props} />,  
  h1: (props) => <h1 className="text-2xl font-bold mt-6 mb-4" {...props} />,  
  h2: (props) => <h2 className="text-xl font-bold mt-5 mb-3" {...props} />,  
  h3: (props) => <h3 className="text-lg font-bold mt-4 mb-2" {...props} />,  
  h4: (props) => <h4 className="text-base font-bold mt-3 mb-2" {...props} />,  
  a: (props) => (  
    <a  
      className="text-primary underline hover:text-primary/80"  
      target="_blank"  
      rel="noopener noreferrer"  
      {...props}  
    />  
  ),  
};  
  
// Main Markdown Component  
export function Markdown({ children, className }: MarkdownProps) {  
  return (  
    <div className={`w-full ${className || ""}`}>  
      <ReactMarkdown  
        remarkPlugins={[remarkGfm]}  
        rehypePlugins={[rehypeHighlight]}  
        components={markdownComponents}  
        skipHtml={false}  
      >  
        {children}  
      </ReactMarkdown>  
    </div>  
  );  
}  --- app/components/sidebar-account.tsx ---
// components/sidebar-account.tsx
"use client";

import * as React from "react";
import { useEffect, useState } from "react";
import { LogOut, Settings2, User2, ChevronsUpDown } from "lucide-react";
import Cookies from "js-cookie";
import { useNavigate } from "@remix-run/react";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "~/components/ui/popover";
import { Button } from "~/components/ui/button";
import { Avatar, AvatarFallback, AvatarImage } from "~/components/ui/avatar";
import { Separator } from "~/components/ui/separator";
import { cn } from "~/lib/utils";
import { getApiUrl, fetchWithHeaders } from "~/lib/api.config";
import {
  KRIVILAK_COOKIE_EMAIL,
  KRIVILAK_COOKIE_DISPLAYNAME,
  KRIVILAK_COOKIE_FIRSTNAME,
  KRIVILAK_COOKIE_LASTNAME,
  KRIVILAK_COOKIE_PROFILE_PIC_URL,
  KRIVILAK_USER_COOKIE_NAMES,
} from "~/lib/user-cookie-keys";

interface User {
  name: string;
  email: string;
  avatar: string; // URL to avatar image
}

// interface SidebarAccountProps {
//   user: User; // User prop removed, will be fetched from cookies
//   onLogout?: () => void; // Optional: For handling logout action - will be handled internally
// }

export function SidebarAccount(/*{ user, onLogout }: SidebarAccountProps*/) {
  const [user, setUser] = useState<User | null>(null);
  const navigate = useNavigate();

  useEffect(() => {
    const email = Cookies.get(KRIVILAK_COOKIE_EMAIL) || "";
    const displayName = Cookies.get(KRIVILAK_COOKIE_DISPLAYNAME);
    const firstName = Cookies.get(KRIVILAK_COOKIE_FIRSTNAME);
    const lastName = Cookies.get(KRIVILAK_COOKIE_LASTNAME);
    const profilePictureUrl = Cookies.get(KRIVILAK_COOKIE_PROFILE_PIC_URL) || "";

    let name = "User";
    if (displayName) {
      name = displayName;
    } else if (firstName && lastName) {
      name = `${firstName} ${lastName}`;
    } else if (firstName) {
      name = firstName;
    }

    if (email) {
      setUser({
        name,
        email,
        avatar: profilePictureUrl,
      });
    }
  }, []);

  const getInitials = (name: string) => {
    if (!name) return "";
    return name
      .split(" ")
      .map((n) => n[0])
      .join("")
      .toUpperCase();
  };

  const handleLogout = async () => {
    try {
      // const logoutUrl = getApiUrl("AUTH_LOGOUT"); // No longer needed, fetchWithHeaders handles it
      await fetchWithHeaders("AUTH_LOGOUT", {
        method: "POST",
        credentials: "include", // Important to send cookies
      });
    } catch (error) {
      console.error("Logout API call failed:", error);
      // Proceed with client-side cleanup even if API call fails
    } finally {
      // Clear all relevant cookies
      KRIVILAK_USER_COOKIE_NAMES.forEach((cookieName) => {
        Cookies.remove(cookieName, { path: "/" }); // Ensure path is correct if cookies were set with a specific path
      });
      // Redirect to login page
      navigate("/login");
    }
  };

  if (!user) {
    // Optionally, render a loading state or nothing if user data isn't available
    // For now, if no user (e.g. no email cookie), don't render the component
    // Or redirect to login if preferred:
    // useEffect(() => { if (!user) navigate("/login"); }, [user, navigate]);
    return null;
  }

  return (
    <div className="w-full p-3">
      <Popover>
        <PopoverTrigger asChild>
          <Button
            variant="ghost"
            className={cn(
              "w-full flex items-center gap-3 px-3 py-2.5 h-auto text-left",
              "text-sm font-medium rounded-md transition-colors",
              "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
              "focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sidebar-ring focus-visible:ring-offset-1 focus-visible:ring-offset-sidebar",
              "data-[state=open]:bg-sidebar-accent data-[state=open]:text-sidebar-accent-foreground"
            )}
            aria-label="Open user menu"
          >
            <Avatar className="size-8 rounded-md">
              <AvatarImage src={user.avatar} alt={user.name} />
              <AvatarFallback className="rounded-md bg-sidebar-primary text-sidebar-primary-foreground text-xs">
                {getInitials(user.name)}
              </AvatarFallback>
            </Avatar>
            <div className="flex-1 grid leading-tight">
              <span className="font-semibold truncate text-sidebar-foreground">{user.name}</span>
              <span className="text-xs truncate text-sidebar-foreground/70">{user.email}</span>
            </div>
            <ChevronsUpDown className="ml-auto size-4 text-sidebar-foreground/60 shrink-0" />
          </Button>
        </PopoverTrigger>
        <PopoverContent
          align="end"
          side="top"
          sideOffset={8}
          className="w-[calc(var(--radix-popover-trigger-width)+20px)] min-w-56 p-1.5 rounded-lg shadow-xl bg-popover text-popover-foreground border border-border"
        >
          <div className="flex items-center gap-3 p-2.5 border-b border-border mb-1">
            <Avatar className="size-9 rounded-md">
              <AvatarImage src={user.avatar} alt={user.name} />
              <AvatarFallback className="rounded-md bg-primary text-primary-foreground text-sm">
                 {getInitials(user.name)}
              </AvatarFallback>
            </Avatar>
            <div className="flex-1 grid leading-tight">
              <p className="text-sm font-semibold text-popover-foreground">{user.name}</p>
              <p className="text-xs text-muted-foreground">{user.email}</p>
            </div>
          </div>

          <nav className="flex flex-col gap-0.5">
            <Button variant="ghost" className="w-full justify-start gap-2.5 px-2.5 py-2 text-sm h-auto font-normal text-popover-foreground hover:bg-accent hover:text-accent-foreground rounded-md">
              <User2 className="size-4 text-muted-foreground" /> My Profile
            </Button>
            <Button variant="ghost" className="w-full justify-start gap-2.5 px-2.5 py-2 text-sm h-auto font-normal text-popover-foreground hover:bg-accent hover:text-accent-foreground rounded-md">
              <Settings2 className="size-4 text-muted-foreground" /> Settings
            </Button>
            <Separator className="my-1 bg-border" />
            <Button
              variant="ghost"
              onClick={handleLogout}
              className="w-full justify-start gap-2.5 px-2.5 py-2 text-sm h-auto font-normal text-destructive hover:bg-destructive/10 hover:text-destructive rounded-md"
            >
              <LogOut className="size-4" /> Logout
            </Button>
          </nav>
        </PopoverContent>
      </Popover>
    </div>
  );
}--- app/components/chat/ModelSelector.tsx ---
// app/components/chat/ModelSelector.tsx
import { ChevronDownIcon, FileDownIcon } from 'lucide-react';
import type { AIModelConfig } from '~/lib/ai-models'; // Adjust path as needed

interface ModelSelectorProps {
  models: AIModelConfig[];
  selectedModel: AIModelConfig;
  onModelChange: (model: AIModelConfig) => void;
  disabled?: boolean;
  className?: string; // Allow passing custom classes
}

export function ModelSelector({
  models,
  selectedModel,
  onModelChange,
  disabled,
  className,
}: ModelSelectorProps) {
  const handleChange = (event: React.ChangeEvent<HTMLSelectElement>) => {
    const selected = models.find(
      (m) =>
        m.model === event.target.value &&
        m.provider ===
          event.target.options[event.target.selectedIndex].dataset.provider
    );
    if (selected) {
      onModelChange(selected);
    }
  };

  return (
    <div className={`inline-block relative ${className || ''}`}>
      <select
        value={selectedModel.model} // Ensure value matches one of the option values
        onChange={handleChange}
        disabled={disabled}
        className="appearance-none text-xs font-medium bg-background hover:bg-muted border border-input rounded-md px-2.5 py-1.5 pr-7 focus:ring-1 focus:ring-primary focus:outline-none focus:border-primary disabled:opacity-70 disabled:cursor-not-allowed"
      >
        {models.map((model) => (
          <option
            key={`${model.provider}-${model.model}`}
            value={model.model}
            data-provider={model.provider}
          >
            {model.displayName}
          </option>
        ))}
      </select>
      <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-1.5 text-muted-foreground">
        <ChevronDownIcon className="h-4 w-4" /> {/* Changed icon and slightly increased size */}
      </div>
    </div>
  );
}--- app/components/chat/ChatInputBar.tsx ---
// app/components/chat/ChatInputBar.tsx
import React, { useRef, useEffect, useState } from 'react';
import { ArrowUp, Paperclip, Settings2, Brain } from 'lucide-react'; // Added Brain
import type { AIModelConfig } from '~/lib/ai-models';
import { ModelSelector } from './ModelSelector'; // Import ModelSelector
import { Switch } from '~/components/ui/switch';
import { Label } from '~/components/ui/label';

const isProbablyMobile = () => typeof window !== 'undefined' && window.innerWidth < 768;

interface ChatInputBarProps {
  input: string;
  onInputChange: (event: React.ChangeEvent<HTMLTextAreaElement>) => void;
  onSubmit: (options: { thinkingEnabled?: boolean }) => void; // Modified onSubmit
  isLoading: boolean;
  availableModels: AIModelConfig[];
  selectedModel: AIModelConfig;
  onModelChange: (model: AIModelConfig) => void;
}

const MIN_TEXTAREA_HEIGHT_REM = 1.625;
const TEXTAREA_PADDING_Y_PX = 20; 
const MAX_TEXTAREA_HEIGHT_PX = 144; 

export function ChatInputBar({
  input,
  onInputChange,
  onSubmit,
  isLoading,
  availableModels,
  selectedModel,
  onModelChange,
}: ChatInputBarProps) {
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const [thinkingEnabled, setThinkingEnabled] = useState(false);

  useEffect(() => {
    // Reset thinking toggle if model changes and doesn't support it
    if (!selectedModel?.uiOptions?.thinkingToggleSettings) {
      setThinkingEnabled(false);
    }
  }, [selectedModel]);

  useEffect(() => {
    const textarea = textareaRef.current;
    if (textarea) {
      textarea.style.height = 'auto'; 
      const scrollHeight = textarea.scrollHeight;
      const newHeight = Math.min(scrollHeight, MAX_TEXTAREA_HEIGHT_PX);
      textarea.style.height = `${newHeight}px`;
    }
  }, [input]);

  const handleTextareaKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    const mobile = isProbablyMobile();
    if (e.key === 'Enter' && (e.shiftKey || e.ctrlKey)) return; 
    if (mobile && e.key === 'Enter') return; 
    if (e.key === 'Enter' && !mobile) {
      e.preventDefault();
      if (!isLoading && (input || '').trim()) {
        const form = e.currentTarget.form;
        if (form) form.requestSubmit();
      }
    }
  };

  const isSendDisabled = isLoading || !(input || '').trim();

  return (
    <div className="w-full flex-shrink-0">
      <form
        onSubmit={(e) => {
          e.preventDefault();
          if (!isLoading && (input || '').trim()) {
            onSubmit({ thinkingEnabled: selectedModel?.uiOptions?.thinkingToggleSettings ? thinkingEnabled : undefined });
          }
        }}
        className="relative mx-auto flex w-full flex-col rounded-xl bg-card p-2.5 shadow-xl ring-1 ring-border sm:p-3"
      >
        <textarea
          ref={textareaRef}
          value={input || ''}
          onChange={onInputChange}
          onKeyDown={handleTextareaKeyDown}
          placeholder={selectedModel ? `Ask ${selectedModel.displayName}...` : 'Select a model...'}
          rows={1}
          className="w-full resize-none overflow-y-auto rounded-lg border-none bg-transparent px-3 py-2.5 text-base text-foreground outline-none placeholder:text-muted-foreground focus:ring-0"
          style={{
            minHeight: `calc(${MIN_TEXTAREA_HEIGHT_REM}rem + ${TEXTAREA_PADDING_Y_PX}px)`,
            maxHeight: `${MAX_TEXTAREA_HEIGHT_PX}px`,
          }}
          disabled={isLoading}
          aria-label="Chat message input"
        />
        <div className="mt-2 flex items-center justify-between">
          <div className="flex items-center gap-1.5">
            <ModelSelector
              models={availableModels}
              selectedModel={selectedModel}
              onModelChange={onModelChange}
              disabled={isLoading || !availableModels || availableModels.length === 0}
            />
            {selectedModel?.uiOptions?.thinkingToggleSettings && (
              <div className="flex items-center space-x-2 ml-2">
                <Switch
                  id="thinking-toggle"
                  checked={thinkingEnabled}
                  onCheckedChange={setThinkingEnabled}
                  disabled={isLoading}
                />
                <Label htmlFor="thinking-toggle" className="flex items-center text-sm text-primary cursor-pointer select-none">
                  <Brain className="w-4 h-4 mr-1" />
                  AI Thinking
                </Label>
              </div>
            )}
          </div>
          <div className="flex items-center gap-1 sm:gap-1.5">
            <button type="button" className="p-1.5 text-muted-foreground hover:text-foreground hover:bg-muted sm:p-2 rounded-md disabled:opacity-50" disabled={true} title="Attach file (soon)">
              <Paperclip size={18} strokeWidth={2} />
            </button>
            <button type="button" className="p-1.5 text-muted-foreground hover:text-foreground hover:bg-muted sm:p-2 rounded-md disabled:opacity-50" disabled={true} title="Model options (soon)">
              <Settings2 size={18} strokeWidth={2} />
            </button>
            <button type="submit" className="flex items-center justify-center rounded-lg bg-primary px-3 py-2 text-primary-foreground hover:bg-primary/90 disabled:opacity-50" disabled={isSendDisabled} title="Send message">
              <ArrowUp size={20} strokeWidth={2.25} />
            </button>
          </div>
        </div>
      </form>
    </div>
  );
}--- app/components/chat/MessageList.tsx ---
// app/components/MessageList.tsx
import type { RefObject } from 'react';
import type { Message } from './MessageItem'; // Assuming MessageItem exports Message type
import { MessageItem } from './MessageItem';

interface MessageListProps {
  messages: Message[];
  isLoading: boolean; // This prop is now only for isInitialHistoryLoading visual cues if any, or can be removed if not used elsewhere
  isInitialHistoryLoading?: boolean;
  scrollEndRef: RefObject<HTMLDivElement>;
}

export function MessageList({
  messages,
  // isLoading, // This prop is no longer used for the assistant typing indicator here
  isInitialHistoryLoading = false, // Keep if used for other purposes
  scrollEndRef,
}: MessageListProps) {
  return (
    <div className="p-4 space-y-4"> {/* Ensure this padding is desired, or remove if MessageItem handles it */}
      {messages.map((msg) => (
        <MessageItem key={msg.id} message={msg} />
      ))}
      
      <div ref={scrollEndRef} style={{ height: '1px' }} />
    </div>
  );
}--- app/components/chat/InitialGreeting.tsx ---
// app/components/chat/InitialGreeting.tsx  
import React from "react";  
  
export function InitialGreeting() {  
  return (  
<div className="flex flex-1 flex-col justify-center items-center min-h-0">  
      <h1 className="text-3xl md:text-4xl font-semibold mb-2 text-neutral-900 dark:text-neutral-100 text-center">  
        How can I help you today?  
      </h1>  
      <div className="h-1 w-24 bg-primary/40 rounded-full my-4" />  
      <p className="text-neutral-500 dark:text-neutral-400 text-center">  
        Start typing below or ask anything.  
      </p>  
    </div>  
  );  
}  --- app/components/chat/MessageItem.tsx ---
// app/components/MessageItem.tsx
import React, { useState, useRef, Fragment } from "react";
import { Markdown } from "../Markdown";
import { Check, Copy, Loader, MessageCircle, Sparkles, ChevronDown, ChevronUp } from "lucide-react";
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from "~/components/ui/collapsible";

export interface Message {
  id: string;
  role: "user" | "assistant" | "system"; // Added "system"
  content: string;
  isLoading?: boolean;
}

interface MessageItemProps {
  message: Message;
}

export function MessageItem({ message }: MessageItemProps) {
  const isUser = message.role === "user";
  const isAssistant = message.role === "assistant";
  const contentBubbleRef = useRef<HTMLDivElement>(null);

  const [copied, setCopied] = useState(false);

  const handleCopy = (textToCopy: string) => {
    navigator.clipboard.writeText(textToCopy).then(() => {
      setCopied(true);
      setTimeout(() => setCopied(false), 1500);
    });
  };

  const parseMessageContent = (content: string) => {
    const parts = [];
    let lastIndex = 0;
    const regex = /<think>([\s\S]*?)<\/think>|<think>([\s\S]*?)<\/think>/gs;
    let match;

    while ((match = regex.exec(content)) !== null) {
      if (match.index > lastIndex) {
        parts.push({ type: "text", content: content.substring(lastIndex, match.index) });
      }
      // Group 1 is for <think>, Group 2 is for <think>
      const thinkContent = match[1] || match[2];
      parts.push({ type: "think", content: thinkContent.trim() });
      lastIndex = regex.lastIndex;
    }

    if (lastIndex < content.length) {
      parts.push({ type: "text", content: content.substring(lastIndex) });
    }
    return parts;
  };


  function AssistantIconRow() {
    return (
      <div className="flex items-center gap-3 mb-2 select-none">
        <div className="w-9 h-9 flex items-center justify-center rounded-full bg-gray-100 shadow text-indigo-700">
          <MessageCircle className="w-6 h-6" />
        </div>
        <span className="italic text-base mr-2">Krivi AI</span>
        {message.isLoading ? (
          <div className="flex items-center gap-2 text-muted-foreground text-sm">
            <Loader className="w-5 h-5 animate-spin" />
            <span>Assistant is typing...</span>
          </div>
        ) : null}
      </div>
    );
  }

  if (isAssistant && message.isLoading && !message.content) {
    return (
      <div
        id={`message-${message.id}`}
        className="flex justify-start mb-4"
        data-role={message.role}
      >
        <div className="flex flex-col items-start max-w-[100%]">
          <AssistantIconRow />
        </div>
      </div>
    );
  }

  return (
    <div
      id={`message-${message.id}`}
      className={`flex ${isUser ? "justify-end" : "justify-start"} mb-4`}
      data-role={message.role}
    >
      <div
        className={`max-w-[100%] flex flex-col ${isUser ? "items-end" : "items-start"}`}
      >
        {isAssistant && <AssistantIconRow />}
        <div
          ref={contentBubbleRef}
          className={
            isUser
              ? "shadow rounded-lg px-3 py-2 bg-primary text-primary-foreground"
              : "prose prose-sm text-foreground p-3"
          }
          style={{
            maxWidth: "100%",
            overflowWrap: "break-word",
            overflowX: "auto",
          }}
        >
          {message.content ? (
            parseMessageContent(message.content).map((part, index) => {
              if (part.type === "think") {
                return (
                  <ThinkBlock key={index} content={part.content} />
                );
              }
              return (
                <Markdown key={index}>{part.content}</Markdown>
              );
            })
          ) : (isUser ? <span> </span> : null)}
        </div>
        {message.content && !message.isLoading && (
          <div className={`flex mt-1 ${isUser ? "justify-end" : "justify-start"}`}>
            <button
              onClick={() => handleCopy(message.content)}
              className="text-muted-foreground hover:text-foreground transition-colors p-1 rounded hover:bg-muted flex items-center gap-1 text-xs"
              aria-label={copied ? "Copied!" : "Copy message"}
            >
              {copied ? (
                <>
                  <Check className="w-3 h-3" />
                  <span>Copied!</span>
                </>
              ) : (
                <>
                  <Copy className="w-3 h-3" />
                  <span>Copy</span>
                </>
              )}
            </button>
          </div>
        )}
      </div>
    </div>
  );
}

interface ThinkBlockProps {
  content: string;
}

function ThinkBlock({ content }: ThinkBlockProps) {
  const [isOpen, setIsOpen] = useState(true); // Default to expanded

  return (
    <Collapsible open={isOpen} onOpenChange={setIsOpen} className="my-2">
      {/* Trigger button with its own background (white/dark gray) and shadow, always rounded */}
      <CollapsibleTrigger
        className={`flex items-center gap-2 p-2 bg-white dark:bg-gray-800 hover:bg-gray-50 dark:hover:bg-gray-700 text-sm font-medium focus-visible:ring-1 focus-visible:ring-ring focus-visible:outline-none w-fit shadow rounded-md`}
      >
        <div className="flex items-center gap-2 text-slate-700 dark:text-slate-200">
          <Sparkles className="w-4 h-4 text-purple-500" />
          <span>Thinking...</span>
        </div>
        {isOpen ? <ChevronUp className="w-4 h-4 text-slate-500 dark:text-slate-400" /> : <ChevronDown className="w-4 h-4 text-slate-500 dark:text-slate-400" />}
      </CollapsibleTrigger>
      
      {/* Content area with its own background (white/dark gray), border, and shadow, appearing below the trigger */}
      <CollapsibleContent className="mt-1 pt-2 pb-3 px-3 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-md shadow-sm">
        <div className="pl-3 border-l-2 border-purple-400 dark:border-purple-600 max-h-[300px] overflow-y-auto">
          <div className="prose prose-sm max-w-full text-slate-600 dark:text-slate-400 [&_p]:text-sm">
            <Markdown>{content}</Markdown>
          </div>
        </div>
      </CollapsibleContent>
    </Collapsible>
  );
}--- app/components/chat/streaming-chat-context.tsx ---
// app/components/chat/streaming-chat-context.tsx
import React, { createContext, useContext, useState, useRef, useCallback, useEffect } from 'react';
import type { Message } from '~/components/chat/MessageItem';
import type { AIModelConfig } from '~/lib/ai-models';
import { API_STREAM_URL, defaultSystemPrompt } from '~/lib/ai-models';
import { fetchWithHeaders } from '~/lib/api.config';

interface StreamData {
  chatId?: string; // Backend might still send this, but we won't use it for session ID determination
  content?: string;
  type?: 'metadata' | 'content_start' | 'stream_end' | 'error' | 'usage_summary' | 'chat_id_update';
  error?: { message: string };
}

export interface StreamingChatContextType {
  messages: Message[];
  isStreaming: boolean;
  streamError: string | null;
  activeStreamChatId: string | null; // ChatId of the stream being processed
  currentUIFocusChatId: string | null; // ChatId the UI is currently focused on
  startStream: (
    prompt: string,
    modelConfig: AIModelConfig,
    chatIdToStream: string, // Authoritative Chat ID for this stream
    thinkingEnabled?: boolean, // Added thinkingEnabled
  ) => Promise<void>; // No longer returns a chatId, as frontend dictates it
  abortStream: (reason?: string) => void;
  setMessagesForContext: (messages: Message[], uiFocusedChatId: string | null) => void;
  clearStreamState: () => void;
}

const StreamingChatContext = createContext<StreamingChatContextType | undefined>(undefined);

export const StreamingChatProvider = ({ children }: { children: React.ReactNode }) => {
  const [messages, setMessages] = useState<Message[]>([]);
  const [isStreaming, setIsStreaming] = useState(false);
  const [streamError, setStreamError] = useState<string | null>(null);
  const [activeStreamChatId, setActiveStreamChatId] = useState<string | null>(null);
  const [currentUIFocusChatId, setCurrentUIFocusChatId] = useState<string | null>(null);

  const abortControllerRef = useRef<AbortController | null>(null);
  const currentAssistantMessageIdRef = useRef<string | null>(null);

  const setMessagesForContext = useCallback((newMessages: Message[], uiFocusedChatId: string | null) => {
    console.log(`Context: setMessagesForContext called. New messages count: ${newMessages.length}, UI Focus: ${uiFocusedChatId}, Current Active Stream: ${activeStreamChatId}`);
    setMessages(newMessages);
    setCurrentUIFocusChatId(uiFocusedChatId);

    if (activeStreamChatId && uiFocusedChatId !== activeStreamChatId && isStreaming) {
      console.log(`Context: UI focus changed to ${uiFocusedChatId} from active stream ${activeStreamChatId}. Aborting stream.`);
      abortControllerRef.current?.abort("UI context changed away from active stream");
      // Reset streaming states, message updates handled by abortStream/finally in startStream
      setIsStreaming(false);
      // setActiveStreamChatId(null); // Keep activeStreamChatId until a new stream starts or state is cleared
      if (currentAssistantMessageIdRef.current) {
        setMessages(prev => prev.map(msg => msg.id === currentAssistantMessageIdRef.current && msg.isLoading ? { ...msg, isLoading: false, content: msg.content || "[Stream context changed]" } : msg));
        currentAssistantMessageIdRef.current = null;
      }
    }
  }, [activeStreamChatId, isStreaming]);

  const clearStreamState = useCallback(() => {
    console.log("Context: clearStreamState called.");
    if (isStreaming && abortControllerRef.current) {
      abortControllerRef.current.abort("Clearing stream state");
    }
    setMessages([]);
    setIsStreaming(false);
    setStreamError(null);
    setActiveStreamChatId(null);
    setCurrentUIFocusChatId(null);
    currentAssistantMessageIdRef.current = null;
    if (abortControllerRef.current) {
      abortControllerRef.current = null;
    }
  }, [isStreaming]);

  const abortStream = useCallback((reason: string = "User requested abort") => {
    if (abortControllerRef.current && !abortControllerRef.current.signal.aborted) {
      console.log(`Context: Aborting stream. Reason: ${reason}`);
      abortControllerRef.current.abort(reason);
    }
    // Ensure state is updated even if abort is called externally / multiple times
    if (isStreaming) {
      setIsStreaming(false);
      if (currentAssistantMessageIdRef.current) {
        setMessages(prev =>
          prev.map(msg =>
            msg.id === currentAssistantMessageIdRef.current && msg.isLoading
              ? { ...msg, isLoading: false, content: msg.content || `[Stream aborted: ${reason}]` }
              : msg
          )
        );
        currentAssistantMessageIdRef.current = null;
      }
    }
    // abortControllerRef.current = null; // Will be reset on next startStream
  }, [isStreaming]);

  const startStream = useCallback(
    async (
      prompt: string,
      modelConfig: AIModelConfig,
      chatIdToStream: string, // Authoritative Chat ID (frontend-generated for new)
      thinkingEnabled?: boolean, // Added thinkingEnabled
    ): Promise<void> => {
      if (isStreaming && abortControllerRef.current && !abortControllerRef.current.signal.aborted) {
        console.warn("Context: Stream already in progress. Aborting previous to start new one.");
        abortControllerRef.current.abort("New stream started, superceded by new request.");
      }

      console.log(`Context: startStream called for chatId: ${chatIdToStream}`);
      setIsStreaming(true);
      setStreamError(null);
      setActiveStreamChatId(chatIdToStream); // This stream is for this ID

      // The user message should already be in `messages` via `setMessagesForContext`
      // We only add the assistant placeholder here.
      const assistantMsgId = crypto.randomUUID();
      currentAssistantMessageIdRef.current = assistantMsgId;
      const assistantPlaceholder: Message = { id: assistantMsgId, role: 'assistant', content: '', isLoading: true };

      setMessages(prevMessages => [...prevMessages, assistantPlaceholder]);

      abortControllerRef.current = new AbortController();

      try {
        const response = await fetchWithHeaders(API_STREAM_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'Accept': 'text/event-stream' },
          body: JSON.stringify((() => {
            const modelId = modelConfig.model; // Use modelId as key, value from modelConfig.model
            const provider = modelConfig.provider;

            // Initialize messages array for the payload
            let messagesForPayload: Array<{role: string, content: string}> = [];

            // Start with messages from modelConfig.requestPayload if they exist, mapping to {role, content}
            // This ensures any pre-defined messages (like a specific system prompt from model config) are included.
            if (modelConfig.requestPayload && Array.isArray(modelConfig.requestPayload.messages)) {
                messagesForPayload = modelConfig.requestPayload.messages.map((m: any) => ({
                    role: m.role,
                    content: m.content
                })).filter((m: any) => typeof m.role === 'string' && typeof m.content === 'string'); // Ensure valid messages
            }

            // Add or Update user message (current input 'prompt')
            // If a 'user' message already exists (e.g. from modelConfig.requestPayload.messages), update its content.
            // Otherwise, add the new user message.
            let userMessageFound = false;
            messagesForPayload = messagesForPayload.map(m => {
                if (m.role === 'user') {
                    userMessageFound = true;
                    return { ...m, content: prompt };
                }
                return m;
            });
            if (!userMessageFound) {
                messagesForPayload.push({ role: 'user', content: prompt });
            }

            // Add or Update system message (using defaultSystemPrompt)
            // If a 'system' message exists (e.g. from modelConfig.requestPayload.messages) and its content is empty,
            // and defaultSystemPrompt is defined, fill the content.
            // If no 'system' message exists and defaultSystemPrompt is defined, add it (typically at the beginning).
            let systemMessageFound = false;
            messagesForPayload = messagesForPayload.map(m => {
                if (m.role === 'system') {
                    systemMessageFound = true;
                    if (!m.content && defaultSystemPrompt) {
                        return { ...m, content: defaultSystemPrompt };
                    }
                }
                return m;
            });
            if (!systemMessageFound && defaultSystemPrompt) {
                messagesForPayload.unshift({ role: 'system', content: defaultSystemPrompt });
            }
            
            // Final filter to ensure all messages in the payload have a role and string content.
            messagesForPayload = messagesForPayload.filter(m => m.role && typeof m.content === 'string');

            return {
              chatId: chatIdToStream,
              provider: provider,
              modelId: modelId, // Key is now modelId
              messages: messagesForPayload, // Messages array is top-level
            };
          })()),
          signal: abortControllerRef.current.signal,
          credentials: 'include',
        });

        if (abortControllerRef.current.signal.aborted) {
          console.log("Context: Stream fetch aborted before response fully processed.");
          // Message update is handled in finally or if abortStream was called directly
          return;
        }

        if (!response.ok || !response.body) {
          const errorBody = await response.text().catch(() => "Failed to read error body");
          setStreamError(`API Error ${response.status}: ${errorBody}`);
          setMessages(prev => prev.map(m => m.id === assistantMsgId ? { ...m, isLoading: false, content: `API Error: ${response.status}` } : m));
          setIsStreaming(false);
          currentAssistantMessageIdRef.current = null;
          return;
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = "";

        while (true) {
          const { done, value } = await reader.read();
          if (abortControllerRef.current?.signal.aborted) {
            console.log("Context: Stream processing loop aborted by signal.");
            // Message update is handled by abortStream or finally block.  
            break;
          }
          if (done) {
            console.log("Context: Stream finished naturally.");
            break;
          }

          buffer += decoder.decode(value, { stream: true });
          let newlineIndex;
          while ((newlineIndex = buffer.indexOf('\n')) >= 0) {
            const line = buffer.slice(0, newlineIndex).trim();
            buffer = buffer.slice(newlineIndex + 1);

            if (line.startsWith("data: ")) {
              const jsonDataString = line.substring(5);
              if (jsonDataString && !abortControllerRef.current?.signal.aborted) {
                try {
                  const chunk: StreamData = JSON.parse(jsonDataString);

                  // ... your chunk handling logic ...  
                  if (chunk.type === 'chat_id_update' && chunk.chatId && chunk.chatId !== chatIdToStream) {
                    console.warn(`Context: Backend sent a chatId ${chunk.chatId} different from frontend's ${chatIdToStream}. Ignoring backend's for session ID.`);
                  }

                  if (chunk.content) {
                    setMessages(prev =>
                      prev.map(msg =>
                        msg.id === assistantMsgId
                          ? { ...msg, content: msg.content + chunk.content, isLoading: true }
                          : msg
                      )
                    );
                  }

                  if (chunk.type === 'stream_end' || chunk.type === 'usage_summary') {
                    // Stream ended from backend's perspective  
                    if (!abortControllerRef.current?.signal.aborted) { // Only if not already handled by an abort  
                      setMessages(prev => prev.map(msg => msg.id === assistantMsgId ? { ...msg, isLoading: false } : msg));
                      setIsStreaming(false);
                      currentAssistantMessageIdRef.current = null;
                    }
                  } else if (chunk.error) {
                    if (!abortControllerRef.current?.signal.aborted) {
                      setStreamError(chunk.error?.message || "Stream error from backend"); // <-- FIXED  
                      setMessages(prev => prev.map(m =>
                        m.id === assistantMsgId
                          ? { ...m, isLoading: false, content: `${m.content || ""}\n[Error: ${chunk.error?.message ?? "Unknown error"}]` }
                          : m
                      ));
                      setIsStreaming(false);
                      currentAssistantMessageIdRef.current = null;
                    }
                    break; // Break from while loop on backend error  
                  }

                  // Optional: break out of the while(line) if error type  
                  if (chunk.type === 'error' || chunk.error) break;

                } catch (e: any) {
                  if (!abortControllerRef.current?.signal.aborted) {
                    console.error("Context: Error parsing stream data JSON:", e, jsonDataString);
                    setStreamError(`Error parsing stream: ${e.message}`);
                    setMessages(prev => prev.map(m => m.id === assistantMsgId ? { ...m, isLoading: false, content: `${m.content || ""}\n[Error parsing stream data]` } : m));
                    setIsStreaming(false);
                    currentAssistantMessageIdRef.current = null;
                  }
                  break; // Break from while loop on parsing error  
                }
              }
            }
          }
        }

        if (!abortControllerRef.current?.signal.aborted && isStreaming) { // Stream ended naturally by `done` or outer break
          setIsStreaming(false);
          setMessages(prev => prev.map(msg => msg.id === assistantMsgId && msg.isLoading ? { ...msg, isLoading: false } : msg));
          currentAssistantMessageIdRef.current = null;
        }

      } catch (error: any) {
        if (error.name === 'AbortError' || abortControllerRef.current?.signal.aborted) {
          console.log(`Context: Stream operation was aborted. Message: ${error.message}`);
          if (isStreaming) setIsStreaming(false);
          setMessages(prev => prev.map(msg => msg.id === assistantMsgId && msg.isLoading ? { ...msg, isLoading: false, content: msg.content || `[Stream aborted]` } : msg));
        } else {
          console.error("Context: Send/Stream error:", error);
          setStreamError(error.message || "An unknown error occurred.");
          setMessages(prev =>
            prev.map(msg =>
              msg.id === assistantMsgId
                ? { ...msg, content: (msg.content || "") + `\n[Error: ${error.message}]`, isLoading: false }
                : msg
            )
          );
          if (isStreaming) setIsStreaming(false);
        }
        if (currentAssistantMessageIdRef.current === assistantMsgId) {
          currentAssistantMessageIdRef.current = null;
        }
      } finally {
        // If stream ended, but not due to abort, and we are still marked as streaming (e.g. loop break), ensure cleanup.
        // This is a safeguard.
        if (isStreaming && (!abortControllerRef.current || !abortControllerRef.current.signal.aborted)) {
          setIsStreaming(false);
          if (currentAssistantMessageIdRef.current === assistantMsgId) {
            setMessages(prev => prev.map(msg => msg.id === assistantMsgId && msg.isLoading ? { ...msg, isLoading: false } : msg));
            currentAssistantMessageIdRef.current = null;
          }
        }
        // The AbortController instance is specific to this call of startStream.
        // It's fine if abortControllerRef.current is overwritten by a subsequent call.
      }
    },
    [isStreaming, abortStream] // Removed currentUIFocusChatId, as chatIdToStream is authoritative
  );

  useEffect(() => {
    return () => {
      if (abortControllerRef.current && !abortControllerRef.current.signal.aborted) {
        console.log("StreamingChatProvider unmounting, aborting any active non-aborted stream.");
        abortControllerRef.current.abort("Provider unmounted");
      }
      abortControllerRef.current = null;
    };
  }, []);

  const contextValue: StreamingChatContextType = {
    messages,
    isStreaming,
    streamError,
    activeStreamChatId,
    currentUIFocusChatId,
    startStream,
    abortStream,
    setMessagesForContext,
    clearStreamState,
  };

  return <StreamingChatContext.Provider value={contextValue}>{children}</StreamingChatContext.Provider>;
};

export const useStreamingChat = (): StreamingChatContextType => {
  const context = useContext(StreamingChatContext);
  if (!context) {
    throw new Error('useStreamingChat must be used within a StreamingChatProvider');
  }
  return context;
};--- app/components/chat/ChatPageLayout.tsx ---
// app/components/chat/ChatPageLayout.tsx  
import React, { useState, useRef, useTransition as useReactTransitionHook, useEffect } from 'react';  
import { useNavigate, useLocation, useNavigation as useRemixNavigation, useParams } from '@remix-run/react';  
import { AImodels, defaultModelConfig } from '~/lib/ai-models';  
import { useScrollToBottom } from '~/hooks/useScrollToBottom';  
import { FiArrowDown } from 'react-icons/fi';  
import { useStreamingChat } from '~/components/chat/streaming-chat-context';  
import { InitialGreeting } from './InitialGreeting';  
import { useSidebarChatHistory } from '~/components/sidebar-chat-history-context';  
import { MessageList } from './MessageList';  
import { ChatInputBar } from './ChatInputBar';  
  
import { usePerChatModelSelection } from '~/hooks/usePerChatModelSelection';  
import { useChatSessionMessages } from '~/hooks/useChatSessionMessages';  
import { useSidebarHistoryRefreshOnChatChange } from '~/hooks/useSidebarHistoryRefreshOnChatChange';  
import { useChatSendMessage } from '~/hooks/useChatSendMessage';  
  
type ChatPageLayoutProps = {  
  initialChatIdFromLoader: string | null;  
  initialMessagesProp: any[];  
};  
  
export function ChatPageLayout({ initialChatIdFromLoader, initialMessagesProp }: ChatPageLayoutProps) {  
  const navigate = useNavigate();  
  const location = useLocation();  
  const params = useParams();  
  const urlChatId = params.chatId || null;  
  const remixNavigation = useRemixNavigation();  
  const [isReactTransitionPending, startReactTransition] = useReactTransitionHook();  
  const streamChat = useStreamingChat();  
  
  const [input, setInput] = useState('');  
  const [isNewChatTransitioning, setIsNewChatTransitioning] = useState(false);  
  
  const chatModelKey = urlChatId || 'new-chat';  
  
  // -- get scroll hook FIRST so scrollToBottom variable is ready before calling other hooks  
  const {  
    containerRef,  
    endRef,  
    showScrollDownButton,  
    scrollToBottom,  
    scrollToPartialView,  
    resetManualScrollFlag  
  } = useScrollToBottom(streamChat.messages);  
  
  const { selectedModel, handleModelChange } = usePerChatModelSelection(chatModelKey, defaultModelConfig);  
  
  const { chatPhase, setChatPhase } = useChatSessionMessages({  
    urlChatId,  
    initialMessagesProp,  
    streamChat,  
    location,  
    remixNavigation,  
    navigate,  
    startReactTransition,  
    isNewChatTransitioning,  
    setIsNewChatTransitioning,  
    scrollToBottom,  
  });  
  
  const lastSelectedModelMapRef = useRef<{ [key: string]: any }>({});  
  
  const handleSendMessage = useChatSendMessage({  
    streamChat,  
    urlChatId,  
    lastSelectedModelMapRef,  
    isReactTransitionPending,  
    chatPhase,  
    navigate,  
    startReactTransition,  
    setInput,  
    setIsNewChatTransitioning,  
    chatModelKey,  
  });  
  
  // For sidebar history  
  const { refreshChatHistory } = useSidebarChatHistory();  
  useSidebarHistoryRefreshOnChatChange(initialChatIdFromLoader, refreshChatHistory);  
  
  useEffect(() => {  
    resetManualScrollFlag();  
  }, [urlChatId, resetManualScrollFlag]);  
  
  // UI event handlers
  const handleFormSubmit = (options: { thinkingEnabled?: boolean }) => {
    // e.preventDefault(); // This is now handled in ChatInputBar.tsx
    if (
      input.trim() &&
      chatPhase === 'READY' &&
      !streamChat.isStreaming &&
      !isReactTransitionPending
    ) {
      handleSendMessage(input, selectedModel, options); // Pass options through
    }
  };
  
  const handlePromptSelect = (promptText: string) => {
    if (chatPhase === 'READY' && !streamChat.isStreaming && !isReactTransitionPending) {
      setInput(promptText);
      // For prompts selected from UI, thinking is likely not explicitly toggled,
      // so we might send undefined or a default.
      // Assuming default behavior (no thinking toggle explicitly set for these).
      handleSendMessage(promptText, selectedModel, { thinkingEnabled: undefined });
    }  
  };  
  
  const isRemixNavigating = remixNavigation.state !== 'idle';  
  const isContentReady =  
    (chatPhase === 'READY' && !isRemixNavigating && !isReactTransitionPending) ||  
    (isNewChatTransitioning && streamChat.messages.length > 0);  
  const childKey = urlChatId || 'new-chat-page-active';  
  
  return (  
    <div className="flex flex-col h-full w-full">  
      <div ref={containerRef} className="flex-grow overflow-y-auto overflow-x-hidden relative">  
        <div  
          style={{  
            opacity: isContentReady ? 1 : 0,  
            transition: 'opacity 0.2s ease-in-out',  
            minHeight: '100%',  
            display: 'flex',  
            flexDirection: 'column',  
          }}  
          className="w-full"  
        >  
          <div className="max-w-4xl mx-auto w-full flex-grow flex flex-col">  
            {streamChat.messages.length === 0 ? (  
              <InitialGreeting />  
            ) : (  
              <MessageList  
                key={`ml-${childKey}`}  
                messages={streamChat.messages}  
                isLoading={  
                  streamChat.isStreaming &&  
                  streamChat.messages[streamChat.messages.length - 1]?.role === 'assistant' &&  
                  streamChat.messages[streamChat.messages.length - 1]?.isLoading === true  
                }  
                isInitialHistoryLoading={false}  
                scrollEndRef={endRef}  
              />  
            )}  
          </div>  
        </div>  
  
        {showScrollDownButton && (  
          <div className="sticky bottom-4 w-full flex justify-center pointer-events-none z-30">  
            <div className="max-w-4xl w-full flex justify-end pointer-events-auto px-4">  
              <button  
                onClick={() => scrollToBottom('smooth')}  
                className="p-2 bg-card border border-border rounded-full shadow-lg hover:bg-muted focus:outline-none focus-visible:ring-2 focus-visible:ring-primary focus-visible:ring-offset-2 focus-visible:ring-offset-background transition-all duration-150 ease-in-out animate-fade-in"  
                aria-label="Scroll to latest messages"  
                title="Scroll to latest messages"  
                style={{ minWidth: 36, minHeight: 36, width: 36, height: 36 }}  
              >  
                <FiArrowDown size={16} aria-hidden="true" />  
              </button>  
            </div>  
          </div>  
        )}  
      </div>  
  
      <div className="flex-shrink-0 bg-background border-t border-border">  
        <div className="max-w-4xl mx-auto w-full p-2 md:p-3">  
          <ChatInputBar  
            key={`cib-${childKey}`}  
            input={input}  
            onInputChange={e => setInput(e.target.value)}  
            onSubmit={handleFormSubmit}  
            isLoading={  
              chatPhase !== 'READY' ||  
              streamChat.isStreaming ||  
              isRemixNavigating ||  
              isReactTransitionPending  
            }  
            availableModels={AImodels}  
            selectedModel={selectedModel}  
            onModelChange={handleModelChange}  
          />  
        </div>  
      </div>  
    </div>  
  );  
}  --- app/components/sidebar-header.tsx ---
// components/sidebar-header.tsx  
"use client";
import * as React from "react";
import { Plus, type LucideIcon } from "lucide-react";
import { Button } from "~/components/ui/button";
import { cn } from "~/lib/utils";
import { Link } from "@remix-run/react"; // For app logo link

interface SidebarHeaderProps extends React.HTMLAttributes<HTMLDivElement> {
  appName: string;
  appIcon: LucideIcon;
  onNewChat?: () => void;

}

export function SidebarHeader({
  className,
  appName,
  appIcon: AppIcon,
  onNewChat,
}: SidebarHeaderProps) {
  return (
    <div className={cn("flex flex-col gap-4 p-4", className)}>
      <Link to="/" prefetch="intent" className="flex items-center gap-3 focus:outline-none group">
        <span className="flex aspect-square size-9 items-center justify-center rounded-lg bg-sidebar-primary text-sidebar-primary-foreground transition-colors group-hover:bg-sidebar-primary/90 group-focus-visible:ring-2 group-focus-visible:ring-ring group-focus-visible:ring-offset-2  group-focus-visible:ring-offset-sidebar">
          <AppIcon className="size-5" />
        </span>
        <span className="font-semibold text-xl tracking-tight text-sidebar-foreground transition-colors group-hover:text-sidebar-foreground/80">
          {appName}
        </span>
      </Link>
      <Button
        variant="default" // Ensure this variant uses sidebar-primary colors or adjust
        size="sm"
        className={cn(
          "w-full flex items-center justify-start gap-2 py-1.5 px-1", // Reduced padding slightly for "New Chat" for better look if text is short
          "text-sm font-medium rounded-md transition-colors",
          // Assuming 'default' variant is styled appropriately for primary action in sidebar
          // If not, explicitly set: "bg-sidebar-primary text-sidebar-primary-foreground hover:bg-sidebar-primary/90",
          "focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sidebar-ring focus-visible:ring-offset-2 focus-visible:ring-offset-sidebar"
        )}
        onClick={onNewChat}
      >
        <Plus className="size-4" />
        <span>New Chat</span>
      </Button>
    </div>
  );
}--- app/components/sidebar-chat-history-context.tsx ---
import * as React from 'react';  
  
interface SidebarChatHistoryContextType {  
  refreshChatHistory: () => void;  
  lastRefreshTimestamp: number;  
}  
  
const SidebarChatHistoryContext = React.createContext<SidebarChatHistoryContextType>({  
  refreshChatHistory: () => {},  
  lastRefreshTimestamp: 0,  
});  
  
export function SidebarChatHistoryProvider({ children }: { children: React.ReactNode }) {  
  const [lastRefreshTimestamp, setLastRefreshTimestamp] = React.useState(Date.now());  
  const refreshChatHistory = React.useCallback(() => setLastRefreshTimestamp(Date.now()), []);  
  return (  
    <SidebarChatHistoryContext.Provider value={{ refreshChatHistory, lastRefreshTimestamp }}>  
      {children}  
    </SidebarChatHistoryContext.Provider>  
  );  
}  
  
export function useSidebarChatHistory() {  
  return React.useContext(SidebarChatHistoryContext);  
}  --- app/components/app-sidebar.tsx ---
// components/app-sidebar.tsx
"use client";

import * as React from "react";
import { SidebarHeader as CustomSidebarHeader } from "./sidebar-header";
import { SidebarAccount } from "./sidebar-account";
import { SidebarNav, type NavItem } from "./sidebar-nav"; // Import NavItem
import {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarHeader,
} from "~/components/ui/sidebar";
import { cn } from "~/lib/utils";
import { Command } from "lucide-react"; // Default app icon
import { getApiUrl } from "~/lib/api.config"; // For logout
import { useNavigate } from "@remix-run/react"; // For navigation

// Define the props AppSidebar expects
interface AppSidebarComponentProps {
  user: {
    name: string;
    email: string;
    avatar: string;
  };
  appName: string;
  mainNav: NavItem[]; // Using NavItem type from sidebar-nav
  // Add other props that might be passed to the underlying Sidebar primitive
}

// Combine with the Sidebar primitive's props, excluding ones we manage
type AppSidebarProps = AppSidebarComponentProps & Omit<React.ComponentProps<typeof Sidebar>, keyof AppSidebarComponentProps>;


export function AppSidebar({
  user,
  appName,
  mainNav,
  className, // from React.ComponentProps<typeof Sidebar>
  ...props // other props for Sidebar primitive
}: AppSidebarProps) {
  const navigate = useNavigate();

  const handleNewChat = () => {
    console.log("New Chat clicked");
    // Implement your new chat logic here, e.g., navigate to a new chat route
    navigate("/"); // This will navigate to the root "/"  
  };

  const handleLogout = async () => {
    // Navigate to the backend logout endpoint.
    // The backend should handle clearing HttpOnly cookies and invalidating the session.
    // After the backend logout, it should redirect the user, perhaps to the login page.
    try {
      const logoutUrl = getApiUrl("AUTH_LOGOUT");
      // We expect the backend to handle the redirect after logout.
      // If it just returns a success/failure, then navigate client-side.
      window.location.href = logoutUrl; // Simplest way to ensure cookies are handled by browser redirect
    } catch (error) {
      console.error("Failed to get logout URL:", error);
      // Fallback or error handling
      navigate("/login?error=logout_failed");
    }
  };


  return (
    <Sidebar
      {...props} // Pass through other props to the Sidebar primitive
      className={cn(
        "bg-sidebar text-sidebar-foreground border-r border-sidebar-border",
        className // Allow overriding classes
      )}
    >
      <SidebarHeader className="p-0">
        <CustomSidebarHeader
          appName={appName}
          appIcon={Command} // You can make appIcon a prop too if it varies
          onNewChat={handleNewChat}
        />
      </SidebarHeader>

      <SidebarContent className="flex-1 overflow-y-auto p-0">
        <SidebarNav mainNav={mainNav} />
      </SidebarContent>

      <SidebarFooter className="p-0 mt-auto border-t border-sidebar-border">
        <SidebarAccount user={user} onLogout={handleLogout} />
      </SidebarFooter>
    </Sidebar>
  );
}--- app/entry.server.tsx ---
/**
 * By default, Remix will handle generating the HTTP Response for you.
 * You are free to delete this file if you'd like to, but if you ever want it revealed again, you can run `npx remix reveal` ✨
 * For more information, see https://remix.run/file-conventions/entry.server
 */

import { PassThrough } from "node:stream";

import type { AppLoadContext, EntryContext } from "@remix-run/node";
import { createReadableStreamFromReadable } from "@remix-run/node";
import { RemixServer } from "@remix-run/react";
import { isbot } from "isbot";
import { renderToPipeableStream } from "react-dom/server";

const ABORT_DELAY = 5_000;

export default function handleRequest(
  request: Request,
  responseStatusCode: number,
  responseHeaders: Headers,
  remixContext: EntryContext,
  // This is ignored so we can keep it in the template for visibility.  Feel
  // free to delete this parameter in your app if you're not using it!
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  loadContext: AppLoadContext
) {
  return isbot(request.headers.get("user-agent") || "")
    ? handleBotRequest(
        request,
        responseStatusCode,
        responseHeaders,
        remixContext
      )
    : handleBrowserRequest(
        request,
        responseStatusCode,
        responseHeaders,
        remixContext
      );
}

function handleBotRequest(
  request: Request,
  responseStatusCode: number,
  responseHeaders: Headers,
  remixContext: EntryContext
) {
  return new Promise((resolve, reject) => {
    let shellRendered = false;
    const { pipe, abort } = renderToPipeableStream(
      <RemixServer
        context={remixContext}
        url={request.url}
        abortDelay={ABORT_DELAY}
      />,
      {
        onAllReady() {
          shellRendered = true;
          const body = new PassThrough();
          const stream = createReadableStreamFromReadable(body);

          responseHeaders.set("Content-Type", "text/html");

          resolve(
            new Response(stream, {
              headers: responseHeaders,
              status: responseStatusCode,
            })
          );

          pipe(body);
        },
        onShellError(error: unknown) {
          reject(error);
        },
        onError(error: unknown) {
          responseStatusCode = 500;
          // Log streaming rendering errors from inside the shell.  Don't log
          // errors encountered during initial shell rendering since they'll
          // reject and get logged in handleDocumentRequest.
          if (shellRendered) {
            console.error(error);
          }
        },
      }
    );

    setTimeout(abort, ABORT_DELAY);
  });
}

function handleBrowserRequest(
  request: Request,
  responseStatusCode: number,
  responseHeaders: Headers,
  remixContext: EntryContext
) {
  return new Promise((resolve, reject) => {
    let shellRendered = false;
    const { pipe, abort } = renderToPipeableStream(
      <RemixServer
        context={remixContext}
        url={request.url}
        abortDelay={ABORT_DELAY}
      />,
      {
        onShellReady() {
          shellRendered = true;
          const body = new PassThrough();
          const stream = createReadableStreamFromReadable(body);

          responseHeaders.set("Content-Type", "text/html");

          resolve(
            new Response(stream, {
              headers: responseHeaders,
              status: responseStatusCode,
            })
          );

          pipe(body);
        },
        onShellError(error: unknown) {
          reject(error);
        },
        onError(error: unknown) {
          responseStatusCode = 500;
          // Log streaming rendering errors from inside the shell.  Don't log
          // errors encountered during initial shell rendering since they'll
          // reject and get logged in handleDocumentRequest.
          if (shellRendered) {
            console.error(error);
          }
        },
      }
    );

    setTimeout(abort, ABORT_DELAY);
  });
}
