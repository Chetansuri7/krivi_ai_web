--- app/lib/utils.ts ---
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
export function isProbablyMobile(): boolean {
  if (typeof window !== "undefined") {
    if (window.matchMedia("(pointer: coarse)").matches) return true;
    // Broader check for mobile devices
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
      navigator.userAgent
    );
  }
  // Fallback for SSR or non-browser environments
  return false;
}--- app/lib/api.config.ts ---
// app/lib/api.config.ts

// For client-side access in Remix + Vite, use VITE_ prefix for env vars
// Make sure VITE_API_BASE_URL is defined in your .env file

// Correctly access environment variables for client and server
export const API_BASE_URL = typeof window !== 'undefined' // Check if running in browser
  ? import.meta.env.VITE_API_BASE_URL // Client-side (Vite)
  : process.env.VITE_API_BASE_URL;   // Server-side (Node.js)

// This check is for build/server time.
if (!API_BASE_URL && typeof process !== 'undefined' && process.env.NODE_ENV !== 'production') {
  console.warn(
    "WARNING: VITE_API_BASE_URL environment variable is not set. Please define it in your .env file (e.g., VITE_API_BASE_URL=https://your-api.com)."
  );
}

export const API_ROUTES = {
  // Auth
  GOOGLE_LOGIN: "/auth/google/login",
  AUTH_REFRESH: "/auth/refresh",
  AUTH_CHECK: "/auth/check",
  AUTH_LOGOUT: "/auth/logout",

  // Chat - Ensure path starts with '/'
  CHAT_SESSION_LIST: "/api/chat/session_list",

  // Other API routes can be added here
  // EXAMPLE_DATA: "/api/example",
};

/**
 * Helper function to construct full API URLs.
 * @param routeKey A key from API_ROUTES
 * @returns The full URL for the API endpoint.
 */
export function getApiUrl(routeKey: keyof typeof API_ROUTES): string {
  if (!API_BASE_URL) {
    const errorMessage = `VITE_API_BASE_URL is not configured or not available. Cannot construct API URL for "${String(routeKey)}". Check your .env file and Vite/Remix configuration. Current URL: ${API_BASE_URL}`;
    console.error(errorMessage);
    throw new Error(errorMessage);
  }
  const path = API_ROUTES[routeKey];
  if (!path) {
    throw new Error(`API route for key "${String(routeKey)}" not found.`);
  }
  return `${API_BASE_URL}${path}`;
}--- app/lib/ai-models.ts ---
// app/lib/ai-models.ts
export interface AIModelConfig {
  displayName: string;
  model: string;
  provider: string;
  isDefault?: boolean; // Optional: useful for selecting default
}

export const AImodels: AIModelConfig[] = [
  {
    displayName: "GPT-4o Mini",
    model: "gpt-4o-mini",
    provider: "azure"
  },
  {
    displayName: "Gemini 2.5 flash", // Updated display name to match model version (optional, adjust as needed)
    model: "gemini-2.5-flash-preview-04-17", // From your example payload
    provider: "google",
    isDefault: true, // Marking this as default as per your previous defaultModelConfig
  },
  {
    displayName: "Gemini 2.0 flash", // Updated display name to match model version (optional, adjust as needed)
    model: "gemini-2.0-flash", // From your example payload
    provider: "google",
  }
  // Add more models here as needed
];

// Select default based on isDefault flag or fallback
export const defaultModelConfig: AIModelConfig = AImodels.find(m => m.isDefault) || AImodels[0];

export const defaultSystemPrompt = "You are a helpful assistant.";
export const API_STREAM_URL = "https://api-chat.kwikon.club/api/chat/stream";
export const API_HISTORY_URL_BASE = "https://api-chat.kwikon.club/api/chat/"; // e.g., append {chatId}/history--- app/lib/auth.server.ts ---
// app/lib/auth.server.ts
import { redirect } from "@remix-run/node";
import { getApiUrl, API_ROUTES } from "./api.config";

// --- Auth Status Types & Helpers ---

// Define a structure for authenticated user details
// Adjust this based on what your /auth/check API returns
export type AuthenticatedUserDetails = {
  id: string;
  name: string;
  email: string;
  avatar_url?: string; // Or 'avatar' if that's the field name
  // any other relevant user fields
};

export type AuthStatus =
  | { status: "authenticated"; reason: "valid_access_token_and_session" | "valid_access_token"; user?: AuthenticatedUserDetails }
  | { status: "login_required"; reason: "session_terminated" | "invalid_or_expired_tokens" | "no_tokens_present" }
  | { status: "refresh_required"; reason: "valid_refresh_token" }
  | { status: "error"; reason?: string };

export function isAuthenticated(auth: AuthStatus): auth is Extract<AuthStatus, { status: "authenticated" }> {
  return auth.status === "authenticated";
}

export function isRefreshable(auth: AuthStatus): auth is Extract<AuthStatus, { status: "refresh_required" }> {
  return auth.status === "refresh_required";
}

// --- Core Auth Functions ---

export async function checkAuth(request: Request): Promise<AuthStatus> {
  try {
    const response = await fetch(getApiUrl("AUTH_CHECK"), {
      method: "GET",
      headers: {
        cookie: request.headers.get("cookie") ?? "",
      },
      credentials: "include",
    });

    if (!response.ok && response.headers.get("content-type")?.includes("application/json")) {
      const data = await response.json();
      // Check if the error response matches AuthStatus structure for login_required or error
      if (data && data.status && (data.status === "login_required" || data.status === "error" || data.status === "refresh_required") && data.reason) {
        return data as AuthStatus;
      }
      return { status: "login_required", reason: data.message || `API error: ${response.status}` };
    } else if (!response.ok) {
      const errorText = await response.text();
      console.error("Auth check API request failed:", response.status, errorText);
      return { status: "error", reason: `API error: ${response.status}. ${errorText}` };
    }

    const data = await response.json();
    // Ensure the success response also matches the AuthStatus structure
    if (data && data.status === "authenticated" && data.reason) {
      // 'user' field is optional in AuthStatus, so it's fine if backend doesn't always send it
      // but for requireAuth, we'll expect it.
      return data as AuthStatus;
    }
    console.error("Auth check API response is not in expected AuthStatus format:", data);
    return { status: "error", reason: "" };
  } catch (error) {
    console.error("Error during checkAuth:", error);
    return { status: "error", reason: "Network error or failed to parse auth/check response" };
  }
}

export async function refreshTokens(request: Request): Promise<{ ok: boolean; setCookieHeader?: string | null }> {
  try {
    const response = await fetch(getApiUrl("AUTH_REFRESH"), {
      method: "POST",
      headers: {
        cookie: request.headers.get("cookie") ?? "",
      },
      credentials: "include",
    });

    const setCookieHeader = response.headers.get("set-cookie");

    if (!response.ok) {
      const errorBody = await response.text();
      console.warn("Refresh token request failed:", response.status, errorBody);
      return { ok: false, setCookieHeader };
    }

    const data = await response.json();
    // Assuming backend returns a success status or specific message
    if (data.status === "Success" || data.message?.includes("refreshed") || data.ok === true || response.status === 200) {
      return { ok: true, setCookieHeader };
    } else {
      console.warn("Refresh token API call was not successful according to response body:", data);
      return { ok: false, setCookieHeader };
    }
  } catch (error) {
    console.error("Error during refreshTokens:", error);
    return { ok: false };
  }
}

export async function requireAuth(  
  request: Request,  
  redirectTo: string = "/login"  
): Promise<Extract<AuthStatus, { status: "authenticated" }>> {  
  let authStatus = await checkAuth(request);  
  
  if (isRefreshable(authStatus)) {  
    const { ok, setCookieHeader } = await refreshTokens(request);  
    if (ok && setCookieHeader) {  
      const currentUrl = new URL(request.url);  
      const destination = currentUrl.pathname + currentUrl.search;  
      throw redirect(destination, {  
        headers: { "Set-Cookie": setCookieHeader },  
      });  
    }  
    authStatus = await checkAuth(request);  
  }  
  
  if (!isAuthenticated(authStatus)) {  
    const currentPath = new URL(request.url).pathname;  
    const currentSearch = new URL(request.url).search;  
    const nextParam =  
      currentPath !== redirectTo && (currentPath !== "/" || currentSearch !== "")  
        ? `?next=${encodeURIComponent(currentPath + currentSearch)}`  
        : "";  
    let reasonParam = "";  
    if (  
      authStatus.status === "login_required" &&  
      authStatus.reason  
    ) {  
      reasonParam = `&error_description=${encodeURIComponent(  
        authStatus.reason  
      )}`;  
    } else if (authStatus.status === "error" && authStatus.reason) {  
      reasonParam = `&error_description=${encodeURIComponent(  
        authStatus.reason  
      )}`;  
    } else if (authStatus.status === "error") {  
      reasonParam = `&error_description=auth_check_failed`;  
    }  
    const finalRedirectTo = `${redirectTo}${nextParam}${nextParam && reasonParam  
      ? reasonParam  
      : !nextParam && reasonParam  
      ? "?" + reasonParam.substring(1)  
      : ""  
      }`;  
  
    throw redirect(finalRedirectTo);  
  }  
  
  // Do NOT check for user presence — just return the auth status  
  return authStatus as Extract<AuthStatus, { status: "authenticated" }>;  
}  --- app/hooks/use-mobile.tsx ---
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    // Ensure window is defined (for SSR safety, though matchMedia is client-only)
    if (typeof window === 'undefined') {
      setIsMobile(false); // Default for server or non-browser env
      return;
    }

    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    // Add listener
    mql.addEventListener("change", onChange)
    // Set initial state
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    // Clean up listener
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}--- app/hooks/useScrollToBottom.ts ---
// app/hooks/useScrollToBottom.ts

import { useRef, useState, useEffect, useCallback } from 'react';

const INTERSECTION_THRESHOLD_PX = 30; // MODIFIED: Was 50, now 30
const USER_SCROLL_DEBOUNCE_MS = 150;

export function useScrollToBottom() {
  const containerRef = useRef<HTMLDivElement | null>(null);
  const endRef = useRef<HTMLDivElement | null>(null);

  const [isAtBottom, setIsAtBottom] = useState(true);
  const [showScrollDownButton, setShowScrollDownButton] = useState(false);
  const scrollTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  const scrollToBottom = useCallback((behavior: ScrollBehavior = 'smooth') => {
    const scrollableContainer = containerRef.current;
    const bottomMarker = endRef.current;

    if (bottomMarker) {
      bottomMarker.scrollIntoView({ behavior });
    } else if (scrollableContainer) {
      scrollableContainer.scrollTo({
        top: scrollableContainer.scrollHeight,
        behavior,
      });
    }
    setIsAtBottom(true);
    setShowScrollDownButton(false);
  }, []);

  useEffect(() => {
    const scrollableContainer = containerRef.current;
    const bottomMarker = endRef.current;

    if (!scrollableContainer || !bottomMarker) {
      setIsAtBottom(true);
      setShowScrollDownButton(false);
      return;
    }

    const observer = new IntersectionObserver(
      ([entry]) => {
        const isCurrentlyIntersecting = entry.isIntersecting;
        setIsAtBottom(isCurrentlyIntersecting);
        setShowScrollDownButton(!isCurrentlyIntersecting);
      },
      {
        root: scrollableContainer,
        rootMargin: `0px 0px ${INTERSECTION_THRESHOLD_PX}px 0px`,
        threshold: 0.01,
      }
    );
    observer.observe(bottomMarker);

    if (
      scrollableContainer.scrollHeight > scrollableContainer.clientHeight &&
      scrollableContainer.scrollTop + scrollableContainer.clientHeight < scrollableContainer.scrollHeight - INTERSECTION_THRESHOLD_PX
    ) {
      setIsAtBottom(false);
      setShowScrollDownButton(true);
    } else {
      setIsAtBottom(true);
      setShowScrollDownButton(false);
    }

    return () => {
      observer.unobserve(bottomMarker);
      observer.disconnect();
    };
  }, [containerRef, endRef]); // Removed INTERSECTION_THRESHOLD_PX from deps as it's const now

  useEffect(() => {
    const scrollableContainer = containerRef.current;
    if (!scrollableContainer) return;

    const handleScroll = () => {
      if (scrollTimeoutRef.current) clearTimeout(scrollTimeoutRef.current);

      scrollTimeoutRef.current = setTimeout(() => {
        if (scrollableContainer) {
          const { scrollTop, scrollHeight, clientHeight } = scrollableContainer;
          const isNearBottom =
            scrollHeight - scrollTop - clientHeight <
            INTERSECTION_THRESHOLD_PX + 5; 

          if (!isNearBottom) {
            if (!showScrollDownButton) setShowScrollDownButton(true);
            if (isAtBottom) setIsAtBottom(false);
          } else {
            if (showScrollDownButton) setShowScrollDownButton(false);
            if (!isAtBottom) setIsAtBottom(true);
          }
        }
      }, USER_SCROLL_DEBOUNCE_MS);
    };

    scrollableContainer.addEventListener('scroll', handleScroll, { passive: true });
    return () => {
      scrollableContainer.removeEventListener('scroll', handleScroll);
      if (scrollTimeoutRef.current) clearTimeout(scrollTimeoutRef.current);
    };
  }, [containerRef, showScrollDownButton, isAtBottom]); // Removed INTERSECTION_THRESHOLD_PX from deps

  return {
    containerRef,
    endRef,
    isAtBottom,
    showScrollDownButton,
    scrollToBottom,
  };
}--- app/root.tsx ---
import {
  Links,
  Meta,
  Outlet,
  Scripts,
  ScrollRestoration,
} from "@remix-run/react";
import type { LinksFunction } from "@remix-run/node"; // No loader needed here if __app.tsx handles auth

import "./tailwind.css";

export const links: LinksFunction = () => [  
  { rel: "preconnect", href: "https://fonts.googleapis.com" },  
  { rel: "preconnect", href: "https://fonts.gstatic.com", crossOrigin: "anonymous" },  
  {  
    rel: "stylesheet",  
    href:  
      "https://fonts.googleapis.com/css2?" +  
      "family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&" +  
      "family=Source+Serif+4:ital@0;1&" +  
      "family=JetBrains+Mono:wght@400;700&" +  
      "display=swap",  
  },  
];  

export function Layout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <Meta />
        <Links />
      </head>
      <body>
        {children}
        <ScrollRestoration />
        <Scripts />
      </body>
    </html>
  );
}

export default function App() {
  // This Outlet will render __app.tsx (for protected routes) or login.tsx, etc.
  return <Outlet />;
}--- app/routes/__app.tsx ---
import type { LoaderFunctionArgs } from "@remix-run/node";  
import { json } from "@remix-run/node";  
import { Outlet, useLoaderData } from "@remix-run/react";  
  
import { requireAuth, type AuthenticatedUserDetails } from "~/lib/auth.server";  
import { AppSidebar } from "~/components/app-sidebar";  
import { SidebarProvider, SidebarInset, SidebarTrigger } from "~/components/ui/sidebar";  
import type { NavItem } from "~/components/sidebar-nav";  
import { Separator } from "~/components/ui/separator";  
  
export interface AppLoaderData {  
  user: AuthenticatedUserDetails;  
  appName: string;  
  mainNavItems: NavItem[];  
}  
  
export async function loader({ request }: LoaderFunctionArgs) {  
  await requireAuth(request);  
  // Provide only dummy data, until real user API is available  
  return json<AppLoaderData>({  
    user: {  
      id: "dummy",  
      name: "Dummy",  
      email: "dummy@example.com",  
      avatar_url: "/avatars/default.png",  
    },  
    appName: "Krivi AI",  
    mainNavItems: [],  
  });  
}  
  
export default function AppLayout() {  
  const { user, appName, mainNavItems } = useLoaderData<typeof loader>();  
  const sidebarUser = {  
    name: user.name,  
    email: user.email,  
    avatar: "/avatars/default.png",  
  };  
  
  return (  
    <SidebarProvider>  
      <AppSidebar  
        user={sidebarUser}  
        appName={appName}  
        mainNav={mainNavItems}  
      />  
      {/* This inset is the "main section" right of the sidebar */}  
      <SidebarInset>  
        {/* COLUMN FLEX for main app area */}  
        <div className="relative flex flex-col h-[100dvh] min-h-0 w-full">  
          {/* The main column, taking whole viewport height */}  
            
          {/*   
            Responsive header height:   
            - 62px on md+ (desktop+)  
            - 31px on mobile  
           */}  
          <header  
            className="  
              sticky top-0 left-0 right-0 z-30 flex  
              h-[41px] md:h-[62px]  
              shrink-0 items-center gap-2 border-b border-border bg-background  
            "  
          >  
            <div className="flex items-center gap-2 px-4">  
              <SidebarTrigger className="-ml-1" />  
              <Separator orientation="vertical" className="mr-2 h-4 bg-border" />  
            </div>  
          </header>  
  
          {/* Main body below topbar, flexes to fill available height */}  
          <main className="relative flex-1 min-h-0 w-full flex flex-col">  
            {/* render whatever the route wants (in your case, ChatPageLayout) */}  
            <Outlet />  
          </main>  
        </div>  
      </SidebarInset>  
    </SidebarProvider>  
  );  
}  --- app/routes/__app.chat.$chatId.tsx ---
// app/routes/__app.chat.$chatId.tsx
import { useLoaderData, useLocation } from "@remix-run/react"; // Added useLocation
import { json, LoaderFunctionArgs, MetaFunction } from "@remix-run/node";
import { requireAuth } from "~/lib/auth.server";
import { ChatPageLayout } from "~/components/chat/ChatPageLayout";
import type { Message } from "~/components/chat/MessageItem";
import { API_HISTORY_URL_BASE } from "~/lib/ai-models";

export const meta: MetaFunction = ({ params }) => [{ title: `Chat ${params.chatId ? `- ${params.chatId.substring(0,8)}` : ''} | Krivi AI` }];

interface LoaderData {
  chatId: string;
  initialMessages: Message[];
  error?: string;
  fromNewChatFlow?: boolean; // From navigation state
}

export async function loader({ request, params }: LoaderFunctionArgs): Promise<ReturnType<typeof json<LoaderData>>> {
  await requireAuth(request);
  const chatId = params.chatId;

  if (!chatId) {
    throw new Response("Chat ID missing", { status: 400 });
  }

  // Check if this load is due to navigation from a new chat flow (see ChatPageLayout navigate state)
  // In a real app, you might get `location.state` on the client, but loader runs on server.
  // The `fromNewChatFlow` flag is more illustrative for client-side logic post-load.
  // For the loader, we always try to fetch history if a chatId is present.
  // The client can then decide whether to use loader messages or state messages.

  let messagesFromHistory: Message[] = [];
  const historyUrl = `${API_HISTORY_URL_BASE}${chatId}/history?limit=50`;

  try {
    const response = await fetch(historyUrl, {
      method: 'GET',
      headers: { 'Cookie': request.headers.get('Cookie') || '' },
    });

    if (response.ok) {
      const data = await response.json();
      if (data.messages && Array.isArray(data.messages)) {
        messagesFromHistory = data.messages.map((msg: any) => ({
          id: msg.id || crypto.randomUUID(), role: msg.role, content: msg.content, createdAt: msg.createdAt,
        }));
      }
    } else {
      // ... (error handling as before)
      console.error(`Failed to fetch chat history for ${chatId}: ${response.status}`);
      return json({ chatId, initialMessages: [], error: `Failed to load history: ${response.status}` });
    }
  } catch (error: any) {
    // ... (error handling as before)
    console.error(`Error fetching chat history for ${chatId}:`, error);
    return json({ chatId, initialMessages: [], error: `Error loading chat: ${error.message}` });
  }
  return json({ chatId, initialMessages: messagesFromHistory });
}

export default function ChatWithIdPage() {
  const loaderData = useLoaderData<LoaderData>();
  const location = useLocation(); // Get location to access state

  // Prefer messages from navigation state if it's from the new chat flow.
  // This provides a smoother UX by showing the already typed messages immediately.
  const messagesFromState = (location.state as { initialMessages?: Message[], fromNewChatFlow?: boolean })?.initialMessages;
  const isFromNewChatFlow = (location.state as { fromNewChatFlow?: boolean })?.fromNewChatFlow;
  
  const finalInitialMessages = (isFromNewChatFlow && messagesFromState && messagesFromState.length > 0) 
                               ? messagesFromState 
                               : loaderData.initialMessages;

  // When navigating between different chat IDs, `loaderData.chatId` will change.
  // This change in prop to `ChatPageLayout` triggers its internal useEffect for cleanup/reset.
  // We also KEY ChatPageLayout by `loaderData.chatId` to ensure a full re-mount
  // when switching between different existing chats. This is a robust way to reset all child state.
  return (
    <ChatPageLayout
      key={loaderData.chatId} // CRITICAL: Re-mounts ChatPageLayout when navigating between different chat IDs
      initialChatId={loaderData.chatId}
      initialMessages={finalInitialMessages}
    />
  );
}--- app/routes/login.tsx ---
// app/routes/login.tsx
import type { LoaderFunctionArgs, MetaFunction } from "@remix-run/node";
import { json, redirect } from "@remix-run/node";
import { useLoaderData, useSearchParams } from "@remix-run/react";
import { FaGoogle } from "react-icons/fa";

import { Button } from "~/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "~/components/ui/card";
import {
  checkAuth,
  refreshTokens,
  isAuthenticated,
  isRefreshable,
  type AuthStatus, // Type import is fine from .server files
} from "~/lib/auth.server";
import { getApiUrl } from "~/lib/api.config"; // Import getApiUrl from client-safe config
import { useIsMobile } from "~/hooks/use-mobile";

export const meta: MetaFunction = () => {
  return [{ title: "Sign In" }];
};

export async function loader({ request }: LoaderFunctionArgs) {
  const url = new URL(request.url);
  const responseHeaders = new Headers();

  let authStatus = await checkAuth(request);

  if (isRefreshable(authStatus)) {
    console.log("[Login Loader] Token refresh required. Attempting refresh...");
    const { ok, setCookieHeader } = await refreshTokens(request);
    if (ok && setCookieHeader) {
      responseHeaders.append("Set-Cookie", setCookieHeader);
      const destination = url.pathname + url.search;
      console.log(`[Login Loader] Refresh successful. Redirecting to ${destination} to apply new cookies.`);
      throw redirect(destination, { headers: responseHeaders });
    }
    authStatus = await checkAuth(request); // Re-check auth after failed refresh
    console.log("[Login Loader] Refresh failed or no cookies set. New auth status:", authStatus.status);
  }

  if (isAuthenticated(authStatus)) {
    const next = url.searchParams.get("next") || "/"; // Default to app's root
    console.log(`[Login Loader] User already authenticated. Redirecting to: ${next}`);
    throw redirect(next, { headers: responseHeaders });
  }

  return json({ authStatus }, { headers: responseHeaders });
}

export default function LoginPage() {  
  const { authStatus } = useLoaderData<typeof loader>();  
  const [searchParams] = useSearchParams();  
  const isMobile = useIsMobile();  
  
  const googleLoginUrl = getApiUrl("GOOGLE_LOGIN");  
  const nextParam = searchParams.get("next");  
  const finalGoogleLoginUrl = nextParam  
    ? `${googleLoginUrl}?final_redirect_path=${encodeURIComponent(nextParam)}`  
    : googleLoginUrl;  
  
  // User-friendly error translation  
  const ERROR_MESSAGES: Record<string, string | undefined> = {  
    session_terminated: "Your session has been terminated. Please sign in again.",  
    invalid_or_expired_tokens: "Your session is invalid or has expired. Please sign in again.",  
    auth_check_failed: "Something went wrong. Please try signing in again.",  
    // add other codes as needed  
  };  
  
  let displayMessage = searchParams.get("message");  
  let errorReason = searchParams.get("error_description") || searchParams.get("error");  
  
  if (!displayMessage && !errorReason && authStatus) {  
    if (authStatus.status === "login_required") {  
      errorReason = ERROR_MESSAGES[authStatus.reason] ?? "";  
    } else if (authStatus.status === "error") {  
      errorReason = ERROR_MESSAGES[authStatus.reason ?? ""] ?? "Something went wrong. Please try signing in again.";  
    }  
  }  
  
  // Never show technical/unknown or empty codes to user  
  if (  
    !errorReason ||  
    ["no_tokens_present", "auth_check_failed", "error", "login_required"].includes(errorReason)  
  ) {  
    errorReason = "";  
  }  
  
  return (  
    <div className="flex min-h-screen items-center justify-center bg-background px-4 py-12">  
      <Card className="w-full max-w-md shadow-xl">  
        <CardHeader className="text-center">  
          <CardTitle className="text-3xl font-bold tracking-tight text-primary">  
            Access Your Account  
          </CardTitle>  
          <CardDescription className="text-muted-foreground pt-2">  
            Continue with Google to securely sign in.  
          </CardDescription>  
        </CardHeader>  
        <CardContent className="space-y-6 pt-6">  
          {errorReason && (  
            <div className="rounded-md border border-destructive/50 bg-destructive/10 p-3 text-center text-sm text-destructive">  
              <p>{errorReason}</p>  
            </div>  
          )}  
          {displayMessage && !errorReason && (  
            <div className="rounded-md border border-primary/50 bg-primary/10 p-3 text-center text-sm text-primary">  
              <p>{displayMessage}</p>  
            </div>  
          )}  
          <Button  
            asChild  
            size={isMobile ? "lg" : "lg"}  
            className="w-full bg-primary text-primary-foreground hover:bg-primary/90 text-lg py-6"  
          >  
            <a href={finalGoogleLoginUrl} className="flex items-center justify-center gap-3">  
              <FaGoogle className="h-5 w-5" />  
              Sign in with Google  
            </a>  
          </Button>  
        </CardContent>  
        <CardFooter className="flex-col items-center text-center pt-6">  
          <p className="text-xs text-muted-foreground">  
            By proceeding, you agree to our Terms of Service and Privacy Policy.  
          </p>  
        </CardFooter>  
      </Card>  
    </div>  
  );  
}  --- app/routes/__app._index.tsx ---
// app/routes/__app._index.tsx
import { useLoaderData } from "@remix-run/react";
import { json, LoaderFunctionArgs, MetaFunction } from "@remix-run/node";
import { requireAuth } from "~/lib/auth.server";
import { ChatPageLayout } from "~/components/chat/ChatPageLayout";
import type { Message } from "~/components/chat/MessageItem"; // Adjust path

export const meta: MetaFunction = () => [{ title: "New Chat | Krivi AI" }];

export async function loader({ request }: LoaderFunctionArgs) {
  await requireAuth(request);
  // For a new chat at the app root, initialChatId is null.
  // No initial messages unless we implement "restore unsaved new chat" later.
  return json({ initialChatId: null, initialMessages: [] });
}

export default function AppRootNewChatPage() {
  const { initialChatId, initialMessages } = useLoaderData<{ 
    initialChatId: null; 
    initialMessages: Message[]; 
  }>();

  // Crucially, ChatPageLayout itself is NOT keyed here.
  // Its internal logic handles the "new chat" state based on initialChatId being null.
  return <ChatPageLayout initialChatId={initialChatId} initialMessages={initialMessages} />;
}--- app/entry.client.tsx ---
/**
 * By default, Remix will handle hydrating your app on the client for you.
 * You are free to delete this file if you'd like to, but if you ever want it revealed again, you can run `npx remix reveal` ✨
 * For more information, see https://remix.run/file-conventions/entry.client
 */

import { RemixBrowser } from "@remix-run/react";
import { startTransition, StrictMode } from "react";
import { hydrateRoot } from "react-dom/client";

startTransition(() => {
  hydrateRoot(
    document,
    <StrictMode>
      <RemixBrowser />
    </StrictMode>
  );
});
--- app/components/sidebar-nav.tsx ---
import * as React from "react";  
import { Link, useNavigate } from "@remix-run/react";  
import { ChevronRight, type LucideIcon as LucideIconType } from "lucide-react";  
import { Collapsible, CollapsibleContent, CollapsibleTrigger } from "~/components/ui/collapsible";  
import { Button } from "~/components/ui/button";  
import { Separator } from "~/components/ui/separator";  
import { cn } from "~/lib/utils";  
import { getApiUrl } from "~/lib/api.config";  
  
type LucideIcon = LucideIconType;  
  
export interface NavSubItem {  
  id: string;  
  title: string;  
  href: string;  
  isActive?: boolean;  
}  
  
export interface NavItem {  
  id: string;  
  title: string;  
  href?: string;  
  icon?: LucideIcon;  
  isActive?: boolean;  
  subItems?: NavSubItem[]; // could be NavItem[] but keep as is for simplicity  
  isGroupLabel?: boolean;  
}  
  
interface SidebarNavProps {  
  mainNav: NavItem[];  
}  
  
interface ApiChatSession {  
  chatId: string;  
  title: string;  
  createdAt: string;  
  lastMessageAt: string;  
}  
  
// --- Utility ---  
const getStartOfDay = (date: Date): Date => {  
  const d = new Date(date);  
  d.setHours(0, 0, 0, 0);  
  return d;  
};  
  
const processChatHistoryToNavItems = (chatSessions: ApiChatSession[]): NavItem[] => {  
  const navItems: NavItem[] = [];  
  if (!Array.isArray(chatSessions) || chatSessions.length === 0) return navItems;  
  
  const now = new Date();  
  const todayStart = getStartOfDay(now);  
  const yesterdayStart = new Date(todayStart);  
  yesterdayStart.setDate(todayStart.getDate() - 1);  
  const sevenDaysAgoStart = new Date(todayStart);  
  sevenDaysAgoStart.setDate(todayStart.getDate() - 7);  
  const thirtyDaysAgoStart = new Date(todayStart);  
  thirtyDaysAgoStart.setDate(todayStart.getDate() - 30);  
  
  const sections: { [key: string]: ApiChatSession[] } = {  
    today: [],  
    yesterday: [],  
    prev7Days: [],  
    prev30Days: [],  
  };  
  
  chatSessions.sort((a, b) => new Date(b.lastMessageAt).getTime() - new Date(a.lastMessageAt).getTime());  
  
  chatSessions.forEach(session => {  
    const sessionDate = new Date(session.lastMessageAt);  
    if (sessionDate >= todayStart)  
      sections.today.push(session);  
    else if (sessionDate >= yesterdayStart)  
      sections.yesterday.push(session);  
    else if (sessionDate >= sevenDaysAgoStart)  
      sections.prev7Days.push(session);  
    else if (sessionDate >= thirtyDaysAgoStart)  
      sections.prev30Days.push(session);  
  });  
  
  const createChatNavItem = (session: ApiChatSession): NavItem => ({  
    id: `chat-${session.chatId}`,  
    title: session.title.length > 30 ? session.title.substring(0, 27) + "..." : session.title,  
    href: `/chat/${session.chatId}`,  
  });  
  
  if (sections.today.length > 0) {  
    navItems.push({ id: 'ch-label-today', title: 'Today', isGroupLabel: true });  
    sections.today.forEach(s => navItems.push(createChatNavItem(s)));  
  }  
  if (sections.yesterday.length > 0) {  
    navItems.push({ id: 'ch-label-yesterday', title: 'Yesterday', isGroupLabel: true });  
    sections.yesterday.forEach(s => navItems.push(createChatNavItem(s)));  
  }  
  if (sections.prev7Days.length > 0) {  
    navItems.push({ id: 'ch-label-prev7', title: 'Previous 7 days', isGroupLabel: true });  
    sections.prev7Days.forEach(s => navItems.push(createChatNavItem(s)));  
  }  
  if (sections.prev30Days.length > 0) {  
    navItems.push({ id: 'ch-label-prev30', title: 'Previous 30 days', isGroupLabel: true });  
    sections.prev30Days.forEach(s => navItems.push(createChatNavItem(s)));  
  }  
  
  return navItems;  
};  
  
// --- NavItemDisplay ---  
/**  
 * For simple links (no sub-items), we disable prefetch for chat history entries (and all simple links by default).  
 * If you have other simple sidebar links you want to keep prefetch="intent", adjust the condition!  
 */  
const NavItemDisplay: React.FC<{ item: NavItem; isSubItem?: boolean }> = ({ item, isSubItem = false }) => {  
  const [isOpen, setIsOpen] = React.useState(item.isActive ?? false);  
  
  if (item.isGroupLabel) {  
    return (  
      <div className="px-3 pt-4 pb-1.5 text-[0.8125rem] font-semibold text-sidebar-foreground">  
        {item.title}  
      </div>  
    );  
  }  
  
  const commonButtonClasses = cn(  
    "w-full justify-start items-center gap-2.5 h-auto px-3 py-1.5 text-[0.8125rem] font-medium",  
    isSubItem && "pl-9 pr-3 py-1.5 text-xs",  
    item.isActive  
      ? "bg-sidebar-accent text-sidebar-accent-foreground"  
      : "text-sidebar-foreground/80 hover:bg-sidebar-accent/60 hover:text-sidebar-accent-foreground",  
    "transition-colors rounded-md"  
  );  
  
  // --- SIMPLE LINK (no subItems): always prefetch="none" for chat history ---  
  if (!item.subItems || item.subItems.length === 0) {  
    return (  
      <Button  
        variant="ghost"  
        asChild  
        className={commonButtonClasses}  
        title={item.title}  
      >  
        <Link  
          to={item.href || "#"}  
          prefetch="none"  
        >  
          {item.icon && (  
            <item.icon className={cn("size-4 shrink-0", isSubItem && "size-3.5")} />  
          )}  
          <span className="truncate flex-1">{item.title}</span>  
        </Link>  
      </Button>  
    );  
  }  
  
  // ---- COLLAPSIBLE GROUP (could have its head as link) ----  
  return (  
    <Collapsible open={isOpen} onOpenChange={setIsOpen} className="w-full">  
      <div className="flex items-center">  
        <Button  
          variant="ghost"  
          asChild={!!item.href}  
          className={cn(commonButtonClasses, "flex-1")}  
          title={item.title}  
          onClick={!item.href ? (e) => { e.preventDefault(); setIsOpen(!isOpen); } : undefined}  
        >  
          {item.href ? (  
            <Link  
              to={item.href}  
              prefetch="none" // For collapsible main link, also prevent prefetch  
              onClick={(e) => {  
                if (item.subItems && item.subItems.length > 0) {  
                  e.preventDefault();  
                  setIsOpen(!isOpen);  
                }  
                // else allow navigation  
              }}  
            >  
              {item.icon && <item.icon className="size-4 shrink-0" />}  
              <span className="truncate flex-1">{item.title}</span>  
            </Link>  
          ) : (  
            <>  
              {item.icon && <item.icon className="size-4 shrink-0" />}  
              <span className="truncate flex-1">{item.title}</span>  
            </>  
          )}  
        </Button>  
        <CollapsibleTrigger asChild>  
          <Button variant="ghost" size="icon" className="ml-1 size-7 shrink-0">  
            <ChevronRight className={cn("size-3.5 transition-transform text-sidebar-foreground/60", isOpen && "rotate-90")} />  
            <span className="sr-only">Toggle {item.title}</span>  
          </Button>  
        </CollapsibleTrigger>  
      </div>  
      <CollapsibleContent className="pl-3.5 mt-0.5 space-y-0.5">  
        {/* Apply the same rule recursively to sub-items: prefetch="none" */}  
        {item.subItems.map((subItem) => (  
          <NavItemDisplay  
            key={subItem.id}  
            // If your subItems are not NavItem, but NavSubItem, convert accordingly:  
            item={{ ...subItem, icon: (subItem as any).icon || undefined }}  
            isSubItem  
          />  
        ))}  
      </CollapsibleContent>  
    </Collapsible>  
  );  
};  
// ----------- MAIN SIDEBARNAV COMPONENT -----------  
export function SidebarNav({ mainNav }: SidebarNavProps) {  
  const [chatHistoryNavItems, setChatHistoryNavItems] = React.useState<NavItem[]>([]);  
  const [isLoadingHistory, setIsLoadingHistory] = React.useState(true);  
  const [errorHistory, setErrorHistory] = React.useState<string | null>(null);  
  
  const refreshChatHistory = React.useCallback(async () => {  
    setIsLoadingHistory(true);  
    setErrorHistory(null);  
    try {  
      const apiUrl = getApiUrl("CHAT_SESSION_LIST");  
      const response = await fetch(apiUrl, {  
        credentials: "include",  
        headers: { "Accept": "application/json" }  
      });  
      if (!response.ok) {  
        let errorData = `API Error: ${response.status} ${response.statusText}`;  
        try {  
          if (response.headers.get("content-type")?.includes("application/json")) {  
            const jsonData = await response.json();  
            errorData = jsonData.message || JSON.stringify(jsonData);  
          } else {  
            errorData = await response.text();  
          }  
        } catch (parseErr) { /* ignore, use statusText */ }  
        throw new Error(errorData);  
      }  
      const data: ApiChatSession[] = await response.json();  
      const processedNavItems = processChatHistoryToNavItems(data);  
      setChatHistoryNavItems(processedNavItems);  
    } catch (err) {  
      console.error("[SidebarNav] Failed to fetch/process chat history:", err);  
      setErrorHistory(err instanceof Error ? err.message : "An unknown error occurred.");  
      setChatHistoryNavItems([]);  
    } finally {  
      setIsLoadingHistory(false);  
    }  
  }, []);  
  
  React.useEffect(() => { refreshChatHistory(); }, [refreshChatHistory]);  
  
  return (  
    <div className="flex flex-col h-full p-2 space-y-1">  
      {mainNav.length > 0 && (  
        <nav className="space-y-0.5">  
          {mainNav.map((item) => <NavItemDisplay key={item.id} item={item} />)}  
        </nav>  
      )}  
  
      {(mainNav.length > 0 && (isLoadingHistory || chatHistoryNavItems.length > 0 || errorHistory)) && (  
        <Separator className="my-2 bg-border/60" />  
      )}  
  
      <div className="px-1 pt-1 pb-1 text-base font-semibold text-sidebar-foreground">  
        Chat History  
      </div>  
  
      <div className="flex-1 overflow-y-auto space-y-0.5 pr-1 custom-scrollbar">  
        {isLoadingHistory ? (  
          <div className="px-3 py-2 text-sm text-sidebar-foreground/70 text-center">  
            Loading history…  
          </div>  
        ) : errorHistory ? (  
          <div className="px-3 py-2 text-sm text-destructive text-center break-words">  
            Error: {errorHistory.substring(0, 150)}{errorHistory.length > 150 && "..."}  
            <Button variant="link" size="sm" onClick={refreshChatHistory} className="mt-1">  
              Try again  
            </Button>  
          </div>  
        ) : chatHistoryNavItems.length > 0 ? (  
          chatHistoryNavItems.map((item) => <NavItemDisplay key={item.id} item={item} />)  
        ) : (  
          <div className="px-3 py-2 text-xs text-sidebar-foreground/60 italic">  
            No chat history found.  
          </div>  
        )}  
      </div>  
    </div>  
  );  
}  --- app/components/Markdown.tsx ---
import React, { useState } from "react";
import ReactMarkdown from "react-markdown";
import type { Components, ExtraProps } from "react-markdown";
import remarkGfm from "remark-gfm";
import rehypeHighlight from "rehype-highlight";
import { FiCopy, FiCheck } from "react-icons/fi";
import "highlight.js/styles/atom-one-dark.css";

import type {
  Element as ProjectHastElement,
  ElementContent as ProjectHastElementContent,
} from "hast";

// Utility to robustly extract text content (for copy)
const extractText = (nodes?: ProjectHastElementContent[]): string =>
  !nodes
    ? ""
    : nodes
        .map((node) => {
          if (node.type === "text") {
            return node.value || "";
          }
          if (node.type === "element" && node.children) {
            return extractText(node.children as ProjectHastElementContent[]);
          }
          return "";
        })
        .join("");

// Component Start
interface MarkdownProps {
  children: string;
  className?: string;
}

// Define the props for the custom code component,
// matching react-markdown's expected CodeProps structure.
type CustomCodeRendererProps = React.DetailedHTMLProps<
  React.HTMLAttributes<HTMLElement>, // Includes className, style, etc.
  HTMLElement
> &
  ExtraProps & { // Includes node?: Element (HAST)
    inline?: boolean; // Specific to code components
    // children will be provided by React.FC or as part of props
  };

const CustomCodeRenderer: React.FC<CustomCodeRendererProps> = ({
  node,
  inline,
  className, // This is the className for syntax highlighting (e.g., "language-js")
  children,
  ...props // Other HTML attributes for the <code> element
}) => {
  const match = /language-(\w+)/.exec(className || "");
  let language = match ? match[1] : undefined;
  if (language === "null" || language === "text" || language === "plaintext") language = undefined;

  const isHeuristicInline =
    node?.position?.start?.line === node?.position?.end?.line && !language;

  const contentString = React.Children.toArray(children)
    .map(child => (typeof child === 'string' || typeof child === 'number') ? child.toString() : '')
    .join('');
  const isContentSingleLine = !contentString.includes("\n");

  if (inline === true || (inline !== false && (isHeuristicInline || isContentSingleLine))) {
    return (
      <code
        // For inline code, we might want to merge the incoming className (if any from markdown like ```text my-class)
        // with our styling classes. However, react-markdown usually puts language in className.
        // For simple inline, the syntax highlighting className might not be relevant.
        className={`bg-muted/50 text-foreground px-1.5 py-0.5 rounded font-mono text-sm ${className || ""}`}
        {...props}
      >
        {children}
      </code>
    );
  }

  const rawCodeContent =
    node && node.children
      ? extractText(node.children as ProjectHastElementContent[])
      : contentString;
  const cleanedCodeForCopy = rawCodeContent.trim();

  const [copied, setCopied] = useState(false);

  return (
    <div className="relative rounded-lg overflow-hidden shadow-sm my-4 border border-border bg-card/50 dark:bg-zinc-900/50">
      <div className="bg-muted/70 dark:bg-zinc-800/70 text-muted-foreground py-1.5 px-4 font-mono text-xs flex items-center justify-between border-b border-border">
        {language ? (
          <span className="uppercase tracking-wider">{language}</span>
        ) : (
          <span>code</span>
        )}
        <button
          className="bg-secondary hover:bg-secondary/80 text-secondary-foreground rounded px-2 py-0.5 text-xs transition-colors flex items-center gap-1 border border-transparent hover:border-border"
          onClick={() => {
            navigator.clipboard.writeText(cleanedCodeForCopy)
              .then(() => {
                setCopied(true);
                setTimeout(() => setCopied(false), 1500);
              }).catch((err) => {
                console.error("Failed to copy:", err);
                setCopied(false)
              });
          }}
          type="button"
          aria-label="Copy code to clipboard"
        >
          {copied ? <FiCheck size={14} className="text-green-500" /> : <FiCopy size={14} />}
        </button>
      </div>
      <pre className="p-4 text-sm font-mono text-foreground overflow-x-auto" style={{ margin: 0, backgroundColor: "transparent" }}>
        {/* The `className` (e.g., "language-js") is passed to the inner <code> for rehype-highlight to work */}
        {/* `props` contains any other HTML attributes for the <code> element */}
        <code className={className} {...props}>
          {children}
        </code>
      </pre>
    </div>
  );
};

// Props for custom list item component
type ListItemComponentProps = React.LiHTMLAttributes<HTMLLIElement> & ExtraProps & {
  checked?: boolean | null;
  ordered?: boolean;
};

const CustomListItemRenderer: React.FC<ListItemComponentProps> = ({
  children,
  checked,
  ordered,
  ...props
}) => {
  if (typeof checked === "boolean") {
    return (
      <li
        className="flex items-start gap-2 my-1.5 ml-0"
        style={{ listStyle: "none" }}
        {...props}
      >
        <span className="pt-0.5">
          {checked ? (
            <svg width="1em" height="1em" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="20" height="20" x="2" y="2" rx="4" fill="currentColor" fillOpacity="0.12"/><path d="M8 12.5l3 3 5-5" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/></svg>
          ) : (
            <svg width="1em" height="1em" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="20" height="20" x="2" y="2" rx="4" fill="currentColor" fillOpacity="0.06"/></svg>
          )}
        </span>
        <span className={checked ? "line-through text-muted-foreground" : ""}>
          {children}
        </span>
      </li>
    );
  }
  return (
    <li
      className={`ml-6 mb-1.5 ${ordered ? "list-decimal" : "list-disc"}`}
      {...props}
    >
      {children}
    </li>
  );
};


const markdownComponents: Components = {
  p: (props) => (
    <p className="my-3 leading-relaxed text-base" {...props} />
  ),
  code: CustomCodeRenderer, // Assign the explicitly typed component
  li: CustomListItemRenderer, // Assign the explicitly typed component for consistency
  h1: (props) => (
    <h1 className="text-3xl font-bold my-4 pb-2 border-b border-border" {...props} />
  ),
  h2: (props) => (
    <h2 className="text-2xl font-semibold my-3 pb-1 border-b border-border" {...props} />
  ),
  h3: (props) => (
    <h3 className="text-xl font-semibold my-2" {...props} />
  ),
  h4: (props) => (
    <h4 className="text-lg font-semibold my-1.5" {...props} />
  ),
  h5: (props) => (
    <h5 className="text-base font-semibold my-1" {...props} />
  ),
  h6: (props) => (
    <h6 className="text-sm font-semibold my-1 text-muted-foreground" {...props} />
  ),
  blockquote: (props) => (
    <blockquote className="my-3 pl-4 border-l-4 border-primary/50 italic text-muted-foreground bg-muted/20 py-2" {...props} />
  ),
  table: (props) => (
    <div className="my-4 overflow-x-auto border border-border rounded-md">
      <table className="min-w-full divide-y divide-border" {...props} />
    </div>
  ),
  thead: (props) => <thead className="bg-muted/50 dark:bg-zinc-800/50" {...props} />,
  tbody: (props) => <tbody className="divide-y divide-border bg-card" {...props} />,
  tr: (props) => <tr className="hover:bg-muted/30 dark:hover:bg-zinc-700/30 transition-colors" {...props} />,
  th: (props) => <th className="px-4 py-2.5 text-left text-xs font-medium text-muted-foreground uppercase tracking-wider" {...props} />,
  td: (props) => <td className="px-4 py-2.5 text-sm text-foreground" {...props} />,
  a: (props) => <a className="text-primary hover:underline" target="_blank" rel="noopener noreferrer" {...props} />,
  ul: (props) => <ul className="my-3 ml-6 list-disc space-y-1" {...props} />,
  ol: (props) => <ol className="my-3 ml-6 list-decimal space-y-1" {...props} />,
  hr: (props) => <hr className="my-4 border-border" {...props} />,
};

export function Markdown({ children, className }: MarkdownProps) {
  return (
    <div className={className}>
      <ReactMarkdown
        remarkPlugins={[remarkGfm]}
        rehypePlugins={[rehypeHighlight]}
        components={markdownComponents}
        skipHtml={false}
      >
        {children}
      </ReactMarkdown>
    </div>
  );
}--- app/components/sidebar-account.tsx ---
// components/sidebar-account.tsx
"use client";

import * as React from "react";
import { LogOut, Settings2, User2, ChevronsUpDown } from "lucide-react"; // Removed Palette for now
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "~/components/ui/popover";
import { Button } from "~/components/ui/button";
import { Avatar, AvatarFallback, AvatarImage } from "~/components/ui/avatar";
import { Separator } from "~/components/ui/separator";
import { cn } from "~/lib/utils";
// import { useTheme } from "next-themes"; // For theme switching, if implemented

interface User {
  name: string;
  email: string;
  avatar: string; // URL to avatar image
}

interface SidebarAccountProps {
  user: User;
  onLogout?: () => void; // Optional: For handling logout action
}

export function SidebarAccount({ user, onLogout }: SidebarAccountProps) {
  // const { theme, setTheme } = useTheme();

  const getInitials = (name: string) => {
    if (!name) return "";
    return name
      .split(" ")
      .map((n) => n[0])
      .join("")
      .toUpperCase();
  };

  const handleLogout = async () => {
    if (onLogout) {
        onLogout();
    } else {
        // Default logout: redirect to backend logout endpoint which should clear cookies
        // This URL needs to come from api.config.ts
        // For now, a placeholder:
        // window.location.href = getApiUrl("AUTH_LOGOUT");
        // Or use Remix Form for a POST request if logout is an action
        console.log("Logout action - implement using Remix form or direct navigation to logout endpoint");
        window.location.href = "/auth/logout"; // Placeholder, use getApiUrl
    }
  };


  return (
    <div className="w-full p-3">
      <Popover>
        <PopoverTrigger asChild>
          <Button
            variant="ghost"
            className={cn(
              "w-full flex items-center gap-3 px-3 py-2.5 h-auto text-left",
              "text-sm font-medium rounded-md transition-colors",
              "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
              "focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sidebar-ring focus-visible:ring-offset-1 focus-visible:ring-offset-sidebar",
              "data-[state=open]:bg-sidebar-accent data-[state=open]:text-sidebar-accent-foreground"
            )}
            aria-label="Open user menu"
          >
            <Avatar className="size-8 rounded-md">
              <AvatarImage src={user.avatar} alt={user.name} />
              <AvatarFallback className="rounded-md bg-sidebar-primary text-sidebar-primary-foreground text-xs">
                {getInitials(user.name)}
              </AvatarFallback>
            </Avatar>
            <div className="flex-1 grid leading-tight">
              <span className="font-semibold truncate text-sidebar-foreground">{user.name}</span>
              <span className="text-xs truncate text-sidebar-foreground/70">{user.email}</span>
            </div>
            <ChevronsUpDown className="ml-auto size-4 text-sidebar-foreground/60 shrink-0" />
          </Button>
        </PopoverTrigger>
        <PopoverContent
          align="end"
          side="top"
          sideOffset={8}
          className="w-[calc(var(--radix-popover-trigger-width)+20px)] min-w-56 p-1.5 rounded-lg shadow-xl bg-popover text-popover-foreground border border-border"
        >
          <div className="flex items-center gap-3 p-2.5 border-b border-border mb-1">
            <Avatar className="size-9 rounded-md">
              <AvatarImage src={user.avatar} alt={user.name} />
              <AvatarFallback className="rounded-md bg-primary text-primary-foreground text-sm">
                 {getInitials(user.name)}
              </AvatarFallback>
            </Avatar>
            <div className="flex-1 grid leading-tight">
              <p className="text-sm font-semibold text-popover-foreground">{user.name}</p>
              <p className="text-xs text-muted-foreground">{user.email}</p>
            </div>
          </div>

          <nav className="flex flex-col gap-0.5">
            <Button variant="ghost" className="w-full justify-start gap-2.5 px-2.5 py-2 text-sm h-auto font-normal text-popover-foreground hover:bg-accent hover:text-accent-foreground rounded-md">
              <User2 className="size-4 text-muted-foreground" /> My Profile
            </Button>
            <Button variant="ghost" className="w-full justify-start gap-2.5 px-2.5 py-2 text-sm h-auto font-normal text-popover-foreground hover:bg-accent hover:text-accent-foreground rounded-md">
              <Settings2 className="size-4 text-muted-foreground" /> Settings
            </Button>
            <Separator className="my-1 bg-border" />
            {/* For Logout, it's better to use a Remix <Form method="post" action="/logout"> or similar */}
            {/* Or a link to a backend endpoint that clears HttpOnly cookies */}
            <Button
              variant="ghost"
              onClick={handleLogout}
              className="w-full justify-start gap-2.5 px-2.5 py-2 text-sm h-auto font-normal text-destructive hover:bg-destructive/10 hover:text-destructive rounded-md"
            >
              <LogOut className="size-4" /> Logout
            </Button>
          </nav>
        </PopoverContent>
      </Popover>
    </div>
  );
}--- app/components/chat/ModelSelector.tsx ---
// app/components/chat/ModelSelector.tsx
import { ChevronDownIcon, FileDownIcon } from 'lucide-react';
import type { AIModelConfig } from '~/lib/ai-models'; // Adjust path as needed

interface ModelSelectorProps {
  models: AIModelConfig[];
  selectedModel: AIModelConfig;
  onModelChange: (model: AIModelConfig) => void;
  disabled?: boolean;
  className?: string; // Allow passing custom classes
}

export function ModelSelector({
  models,
  selectedModel,
  onModelChange,
  disabled,
  className,
}: ModelSelectorProps) {
  const handleChange = (event: React.ChangeEvent<HTMLSelectElement>) => {
    const selected = models.find(
      (m) =>
        m.model === event.target.value &&
        m.provider ===
          event.target.options[event.target.selectedIndex].dataset.provider
    );
    if (selected) {
      onModelChange(selected);
    }
  };

  return (
    <div className={`inline-block relative ${className || ''}`}>
      <select
        value={selectedModel.model} // Ensure value matches one of the option values
        onChange={handleChange}
        disabled={disabled}
        className="appearance-none text-xs font-medium bg-background hover:bg-muted border border-input rounded-md px-2.5 py-1.5 pr-7 focus:ring-1 focus:ring-primary focus:outline-none focus:border-primary disabled:opacity-70 disabled:cursor-not-allowed"
      >
        {models.map((model) => (
          <option
            key={`${model.provider}-${model.model}`}
            value={model.model}
            data-provider={model.provider}
          >
            {model.displayName}
          </option>
        ))}
      </select>
      <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-1.5 text-muted-foreground">
        <FileDownIcon className="h-3.5 w-3.5" />
      </div>
    </div>
  );
}--- app/components/chat/ChatInputBar.tsx ---
// app/components/ChatInputBar.tsx
import React, { useRef, useEffect } from 'react';
import { ArrowUp, Paperclip, Settings2, ChevronDown as SelectChevronDown } from 'lucide-react'; // Renamed ChevronDown
import type { AIModelConfig } from '~/lib/ai-models';
// Assuming isProbablyMobile exists, if not, you can mock it or remove its usage for this stub
const isProbablyMobile = () => typeof window !== 'undefined' && window.innerWidth < 768;


interface ChatInputBarProps {
input: string;
onInputChange: (event: React.ChangeEvent<HTMLTextAreaElement>) => void;
onSubmit: (e: React.FormEvent<HTMLFormElement>) => void;
isLoading: boolean;
availableModels: AIModelConfig[];
selectedModel: AIModelConfig;
onModelChange: (model: AIModelConfig) => void;
}

const MIN_TEXTAREA_HEIGHT_REM = 1.625;
const TEXTAREA_PADDING_Y_PX = 20;
const MAX_TEXTAREA_HEIGHT_PX = 144;

export function ChatInputBar({
input,
onInputChange,
onSubmit,
isLoading,
availableModels,
selectedModel,
onModelChange,
}: ChatInputBarProps) {
const textareaRef = useRef<HTMLTextAreaElement>(null);

useEffect(() => {
    const textarea = textareaRef.current;
    if (textarea) {
    textarea.style.height = 'auto';
    const scrollHeight = textarea.scrollHeight;
    const newHeight = Math.min(scrollHeight, MAX_TEXTAREA_HEIGHT_PX);
    textarea.style.height = `${newHeight}px`;
    }
}, [input]);

const handleTextareaKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    const mobile = isProbablyMobile();
    if (e.key === 'Enter' && (e.shiftKey || e.ctrlKey)) return;
    if (mobile && e.key === 'Enter') return;
    if (e.key === 'Enter' && !mobile) {
    e.preventDefault();
    if (!isLoading && (input || '').trim()) {
        const form = e.currentTarget.form;
        if (form) form.requestSubmit();
    }
    }
};

const handleModelSelectChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const modelIdentifier = e.target.value;
    const provider = e.target.options[e.target.selectedIndex].dataset.provider;
    const newSelectedModel = availableModels.find(
    (m) => m.model === modelIdentifier && m.provider === provider
    );
    if (newSelectedModel) onModelChange(newSelectedModel);
};

const isSendDisabled = isLoading || !(input || '').trim();

return (
    <div className="w-full flex-shrink-0">
    <form
        onSubmit={onSubmit}
        className="relative mx-auto flex w-full flex-col rounded-xl bg-card p-2.5 shadow-xl ring-1 ring-border sm:p-3"
    >
        <textarea
        ref={textareaRef}
        value={input || ''}
        onChange={onInputChange}
        onKeyDown={handleTextareaKeyDown}
        placeholder={selectedModel ? `Ask ${selectedModel.displayName}...` : 'Select a model...'}
        rows={1}
        className="w-full resize-none overflow-y-auto rounded-lg border-none bg-transparent px-3 py-2.5 text-base text-foreground outline-none placeholder:text-muted-foreground focus:ring-0"
        style={{
            minHeight: `calc(${MIN_TEXTAREA_HEIGHT_REM}rem + ${TEXTAREA_PADDING_Y_PX}px)`,
            maxHeight: `${MAX_TEXTAREA_HEIGHT_PX}px`,
        }}
        disabled={isLoading}
        aria-label="Chat message input"
        />
        <div className="mt-2 flex items-center justify-between">
        <div className="flex items-center gap-1.5">
            <div className="relative">
            <select
                value={selectedModel?.model || ''}
                onChange={handleModelSelectChange}
                disabled={isLoading || !availableModels || availableModels.length === 0}
                className="appearance-none rounded-lg border border-input bg-background py-1.5 pl-3 pr-7 text-xs font-medium shadow-sm hover:border-primary focus:border-primary focus:outline-none focus:ring-1 focus:ring-primary disabled:opacity-60"
                aria-label="Select AI Model"
            >
                {(!availableModels || availableModels.length === 0) && (<option value="">Loading...</option>)}
                {availableModels.map((m) => (
                <option key={`${m.provider}-${m.model}`} value={m.model} data-provider={m.provider}>
                    {m.displayName}
                </option>
                ))}
            </select>
            <SelectChevronDown className="pointer-events-none absolute right-2 top-1/2 h-3.5 w-3.5 -translate-y-1/2 text-muted-foreground" />
            </div>
        </div>
        <div className="flex items-center gap-1 sm:gap-1.5">
            <button type="button" className="p-1.5 text-muted-foreground hover:text-foreground hover:bg-muted sm:p-2 rounded-md disabled:opacity-50" disabled={true} title="Attach file (soon)">
            <Paperclip size={18} strokeWidth={2} />
            </button>
            <button type="button" className="p-1.5 text-muted-foreground hover:text-foreground hover:bg-muted sm:p-2 rounded-md disabled:opacity-50" disabled={true} title="Model options (soon)">
            <Settings2 size={18} strokeWidth={2} />
            </button>
            <button type="submit" className="flex items-center justify-center rounded-lg bg-primary px-3 py-2 text-primary-foreground hover:bg-primary/90 disabled:opacity-50" disabled={isSendDisabled} title="Send message">
            <ArrowUp size={20} strokeWidth={2.25} />
            </button>
        </div>
        </div>
    </form>
    </div>
);
}--- app/components/chat/MessageList.tsx ---
// app/components/MessageList.tsx
import type { RefObject } from 'react';
import type { Message } from './MessageItem'; // Assuming MessageItem exports Message type
import { MessageItem } from './MessageItem';

interface MessageListProps {
messages: Message[];
isLoading: boolean; // For assistant typing indicator
isInitialHistoryLoading?: boolean;
scrollEndRef: RefObject<HTMLDivElement>;
}

export function MessageList({
messages,
isLoading,
isInitialHistoryLoading = false,
scrollEndRef,
}: MessageListProps) {
return (
    <div className="p-4 space-y-4"> {/* Ensure this padding is desired, or remove if MessageItem handles it */}
    {messages.map((msg) => (
        <MessageItem key={msg.id} message={msg} />
    ))}
    {isLoading && messages.length > 0 && messages[messages.length - 1]?.role === 'user' && (
        <div className="flex justify-start mb-4"> {/* Assistant typing indicator */}
        <div className="max-w-[70%] p-3 rounded-lg shadow bg-muted">
            <div className="flex items-center space-x-2">
            <div className="w-2 h-2 bg-gray-500 rounded-full animate-pulse"></div>
            <div className="w-2 h-2 bg-gray-500 rounded-full animate-pulse delay-75"></div>
            <div className="w-2 h-2 bg-gray-500 rounded-full animate-pulse delay-150"></div>
            </div>
        </div>
        </div>
    )}
    <div ref={scrollEndRef} style={{ height: '1px' }} />
    </div>
);
}--- app/components/chat/InitialPrompts.tsx ---
interface InitialPromptsProps {
  onPromptSelect: (prompt: string) => void;
}

const suggestions = [
  "What are the advantages of using Next.js?",
  "Write code to demonstrate Dijkstra's algorithm",
  "Help me write an essay about Silicon Valley",
  "What is the weather in San Francisco?",
];

export function InitialPrompts({ onPromptSelect }: InitialPromptsProps) {
  return (
    <div className="flex flex-col items-center justify-center h-full p-4">
      <h1 className="text-3xl font-semibold mb-2">Hello there!</h1>
      <p className="text-muted-foreground mb-8">How can I help you today?</p>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4 w-full max-w-xl">
        {suggestions.map((prompt) => (
          <button
            key={prompt}
            onClick={() => onPromptSelect(prompt)}
            className="p-4 border rounded-lg hover:bg-muted text-left text-sm" // Basic styling
          >
            <p className="font-medium">{prompt.split(' ').slice(0, 5).join(' ')}{prompt.split(' ').length > 5 ? '...' : ''}</p>
            <p className="text-xs text-muted-foreground mt-1">
              {prompt.startsWith("Write code") ? "Code generation" : 
               prompt.startsWith("Help me write") ? "Writing assistance" : 
               "General query"}
            </p>
          </button>
        ))}
      </div>
    </div>
  );
}--- app/components/chat/MessageItem.tsx ---
import React from 'react';  
import { Markdown } from '../Markdown';  
import { Copy } from 'lucide-react'; // You still use this for the copy button  
import { SiBoat } from 'react-icons/si';  
  
// Message interface  
export interface Message {  
  id: string;  
  role: 'user' | 'assistant';  
  content: string;  
}  
  
interface MessageItemProps {  
  message: Message;  
}  
  
export function MessageItem({ message }: MessageItemProps) {  
  const isUser = message.role === 'user';  
  const messageRef = React.useRef<HTMLDivElement>(null);  
  
  const handleCopy = () => {  
    if (messageRef.current) {  
      const textToCopy = messageRef.current.innerText;  
      navigator.clipboard.writeText(textToCopy);  
      // Add toast notification here if needed  
    }  
  };  
  
  return (  
    <div className={`flex ${isUser ? 'justify-end' : 'justify-start'} mb-4`}>  
      <div className={`max-w-[100%] md:max-w-[100%] flex flex-col ${isUser ? 'items-end' : 'items-start'}`}>  
        {/* Header - only for assistant */}  
        {!isUser && (  
          <div className="flex items-center mb-1 px-3">  
            <div className="w-9 h-9 rounded-full bg-white flex items-center justify-center mr-2">  
              <SiBoat color="#7c3aed" className="text-2xl" />  
            </div>  
            <span className="font-semibold text-sm text-violet-600">AI</span>  
          </div>  
        )}  
  
        {/* Message content */}  
        <div  
          ref={messageRef}  
          className={  
            isUser  
              ? `px-3 py-2 rounded-lg shadow bg-primary text-primary-foreground   
                  prose prose-sm md:prose-base dark:prose-invert break-words prose-primary-invert`  
              : `px-3 py-2   
                  prose prose-sm md:prose-base dark:prose-invert break-words text-foreground`  
          }  
        >  
          <Markdown>{message.content}</Markdown>  
        </div>  
  
        {/* Action buttons row - properly aligned with message width */}  
        <div  
          className={`flex mt-1 space-x-2 ${isUser ? 'justify-end' : 'justify-start'}`}  
          style={{ width: 'fit-content' }}  
        >  
          <button  
            onClick={handleCopy}  
            className="text-muted-foreground hover:text-foreground transition-colors p-1 rounded hover:bg-muted"  
            aria-label="Copy message"  
          >  
            <Copy className="w-4 h-4" />  
          </button>  
          {/* Add more action buttons here later */}  
        </div>  
      </div>  
    </div>  
  );  
}  --- app/components/chat/ChatPageLayout.tsx ---
// app/components/chat/ChatPageLayout.tsx

import { useState, useEffect, useCallback, useRef, useTransition as useReactTransitionHook } from 'react';
import { useNavigate, useLocation, useNavigation } from '@remix-run/react';
import type { Message } from './MessageItem';
import { MessageList } from './MessageList';
import { ChatInputBar } from './ChatInputBar';
import { InitialPrompts } from './InitialPrompts';
import {
  AImodels,
  defaultModelConfig,
  defaultSystemPrompt,
  API_STREAM_URL,
} from '~/lib/ai-models';
import type { AIModelConfig } from '~/lib/ai-models';
import { FourSquare } from 'react-loading-indicators';
// import { ChevronDown } from 'lucide-react'; // SVG is used directly
import { useScrollToBottom } from '~/hooks/useScrollToBottom';
import { FiArrowDown } from 'react-icons/fi';

type ChatLoadingPhase = 'INITIALIZING' | 'PREPARING_CONTENT' | 'READY';

interface ChatPageLayoutProps {
  initialChatId: string | null;
  initialMessages?: Message[];
}

export function ChatPageLayout({
  initialChatId,
  initialMessages = [],
}: ChatPageLayoutProps) {
  const navigate = useNavigate();
  const location = useLocation();
  const remixNavigation = useNavigation();
  const [isReactTransitionPending, startReactTransition] = useReactTransitionHook();

  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState('');
  const [isStreaming, setIsStreaming] = useState(false);
  const [selectedModel, setSelectedModel] = useState<AIModelConfig>(defaultModelConfig);
  const [chatPhase, setChatPhase] = useState<ChatLoadingPhase>('READY');

  const abortControllerRef = useRef<AbortController | null>(null);
  const messagesRef = useRef(messages);
  const activeChatContextIdRef = useRef<string | null | symbol>(Symbol('initial_unprocessed_ref_state'));

  const {
    containerRef,
    endRef,
    showScrollDownButton,
    scrollToBottom,
  } = useScrollToBottom();

  useEffect(() => {
    messagesRef.current = messages;
  }, [messages]);

  // ... (rest of your useEffects and handler functions remain the same) ...
  // handleSendMessage, handleStreamData, handleStreamError, etc.

  useEffect(() => {
    const newContextTargetId = initialChatId;
    const navState = location.state as { fromNewChatFlow?: boolean; initialMessages?: Message[] } | null;
    let shouldScrollOnLoad = false;

    if (
      navState?.fromNewChatFlow &&
      navState.initialMessages &&
      initialChatId &&
      initialChatId === activeChatContextIdRef.current
    ) {
      setMessages(navState.initialMessages);
      setChatPhase('READY');
      shouldScrollOnLoad = true;
      startReactTransition(() => {
        const { state, ...restOfLocation } = location;
        // @ts-ignore
        const { fromNewChatFlow, initialMessages: _im, ...newStateWithoutFlow } = state || {};
        navigate(restOfLocation, {
          replace: true,
          state: Object.keys(newStateWithoutFlow).length > 0 ? newStateWithoutFlow : undefined
        });
      });
    } else if (newContextTargetId !== activeChatContextIdRef.current) {
      activeChatContextIdRef.current = newContextTargetId;
      if (abortControllerRef.current) {
        abortControllerRef.current.abort("Chat context changed");
        abortControllerRef.current = null;
      }
      setIsStreaming(false);
      setInput('');
      setMessages([]);
      if (newContextTargetId) {
        setChatPhase('INITIALIZING');
        // Scroll will happen in Effect 3 after PREPARING_CONTENT
      } else {
        setMessages(initialMessages || []);
        setChatPhase('READY');
        shouldScrollOnLoad = true;
      }
    }

    if (shouldScrollOnLoad) {
      requestAnimationFrame(() => scrollToBottom('auto'));
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [initialChatId, location.state, navigate]); // scrollToBottom is stable

  useEffect(() => {
    if (
      chatPhase === 'INITIALIZING' &&
      initialChatId &&
      activeChatContextIdRef.current === initialChatId
    ) {
      setMessages(initialMessages || []);
      setChatPhase('PREPARING_CONTENT');
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [chatPhase, initialMessages, initialChatId]);

  useEffect(() => {
    if (
      chatPhase === 'PREPARING_CONTENT' &&
      activeChatContextIdRef.current === initialChatId
    ) {
      startReactTransition(() => {
        setChatPhase('READY');
        requestAnimationFrame(() => scrollToBottom('auto'));
      });
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [messages, chatPhase, initialChatId]); // scrollToBottom is stable

  useEffect(() => {
    return () => {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort("Component unmounting");
        abortControllerRef.current = null;
      }
    };
  }, []);

  const handleSendMessage = useCallback(
    async (inputText: string, modelConfig: AIModelConfig) => {
      if (isStreaming || isReactTransitionPending || chatPhase !== 'READY') return;
      if (initialChatId && activeChatContextIdRef.current !== initialChatId) return;

      setIsStreaming(true);
      const currentInput = input || inputText;
      setInput('');
      const newUserMessage: Message = {
        id: crypto.randomUUID(),
        role: 'user',
        content: currentInput.trim(),
      };
      setMessages(prev => [...prev, newUserMessage]);

      const assistantMessageId = crypto.randomUUID();
      setMessages(prev => [
        ...prev,
        {
          id: assistantMessageId,
          role: 'assistant',
          content: '',
          timestamp: Date.now(),
        }
      ]);

      const currentAbortController = new AbortController();
      abortControllerRef.current = currentAbortController;
      const chatIdForRequest = initialChatId;
      let receivedChatIdFromStream: string | null = null;

      try {
        const response = await fetch(API_STREAM_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'Accept': 'text/event-stream' },
          body: JSON.stringify({
            chatId: chatIdForRequest,
            message: currentInput.trim(),
            provider: modelConfig.provider,
            model: modelConfig.model,
            systemPrompt: defaultSystemPrompt,
          }),
          signal: currentAbortController.signal,
          credentials: 'include',
        });

        if (currentAbortController.signal.aborted) return;
        if (!response.ok || !response.body) {
          const errorBody = await response.text().catch(() => "Failed to read error body");
          throw new Error(`API Error ${response.status}: ${errorBody.slice(0, 500)}`);
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = "";

        // eslint-disable-next-line no-constant-condition
        while (true) {
          const { done, value } = await reader.read();
          if (currentAbortController.signal.aborted || done) break;
          buffer += decoder.decode(value, { stream: true });
          let newlineIndex;
          while ((newlineIndex = buffer.indexOf('\n')) >= 0) {
            const line = buffer.slice(0, newlineIndex).trim();
            buffer = buffer.slice(newlineIndex + 1);
            if (line.startsWith("data: ")) {
              const jsonDataString = line.substring(5);
              if (jsonDataString && !currentAbortController.signal.aborted) {
                try {
                  const chunk = JSON.parse(jsonDataString);
                  if (chunk.type === "session_info" && chunk.chatId && !chatIdForRequest) {
                    receivedChatIdFromStream = chunk.chatId;
                  }
                  handleStreamData(chunk, assistantMessageId);
                } catch (e) {
                  if (!currentAbortController.signal.aborted) console.error("Error parsing stream data JSON:", e, jsonDataString);
                }
              }
            }
          }
        }

        if (!chatIdForRequest && receivedChatIdFromStream) {
          activeChatContextIdRef.current = receivedChatIdFromStream;
          startReactTransition(() => {
            navigate(`/chat/${receivedChatIdFromStream}`, {
              replace: true,
              state: { initialMessages: messagesRef.current, fromNewChatFlow: true }
            });
          });
        } else if (!currentAbortController.signal.aborted) {
          setIsStreaming(false);
        }
      } catch (error: any) {
        if (
          currentAbortController.signal.aborted ||
          error.name === 'AbortError'
        ) {
          if (
            !messagesRef.current.find(m => m.id === assistantMessageId)?.content?.includes("[Stream aborted]")
          ) {
            setMessages(prev =>
              prev.map(
                msg =>
                  msg.id === assistantMessageId && msg.role === 'assistant'
                    ? {
                      ...msg,
                      content: (msg.content || "") + `\n[Stream aborted]`
                    }
                    : msg
              )
            );
          }
        } else {
          console.error(`[handleSendMessage] Send/Stream error:`, error);
          handleStreamError(assistantMessageId, error.message || "Failed to get response.");
        }
        if (
          !receivedChatIdFromStream || error
        ) {
          if (
            !currentAbortController.signal.aborted ||
            (abortControllerRef.current === currentAbortController || !abortControllerRef.current)
          ) {
            setIsStreaming(false);
          }
        }
      } finally {
        if (abortControllerRef.current === currentAbortController) {
          abortControllerRef.current = null;
        }
      }
    },
    [initialChatId, isStreaming, selectedModel, navigate, isReactTransitionPending, chatPhase, startReactTransition, input]
  );

  const handleStreamData = (chunk: any, assistantMessageId: string) => {
    if (abortControllerRef.current?.signal.aborted && !isStreaming) return; // Check isStreaming too
    if (chunk.content) {
      setMessages(prev =>
        prev.map(
          msg =>
            msg.id === assistantMessageId && msg.role === 'assistant'
              ? { ...msg, content: msg.content + chunk.content }
              : msg
        )
      );
    } else if (chunk.type === 'usage_summary' || chunk.type === 'stream_end') {
      if (!abortControllerRef.current || !abortControllerRef.current.signal.aborted) setIsStreaming(false);
    } else if (chunk.error) {
      handleStreamError(assistantMessageId, chunk.error.message || chunk.error);
      if (!abortControllerRef.current || !abortControllerRef.current.signal.aborted) setIsStreaming(false);
    }
  };

  const handleStreamError = (assistantMessageId: string, errorMessage: string) => {
    setMessages(prev =>
      prev.map(
        msg =>
          msg.id === assistantMessageId &&
            msg.role === 'assistant' &&
            !msg.content.includes("[Error:")
            ? {
              ...msg,
              content: (msg.content || "") + `\n[Error: ${errorMessage.slice(0, 100)}...]`
            }
            : msg
      )
    );
    if (!abortControllerRef.current || !abortControllerRef.current.signal.aborted) setIsStreaming(false);
  };

  const handleFormSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    if (input.trim() && chatPhase === 'READY' && !isStreaming && !isReactTransitionPending) {
      handleSendMessage(input.trim(), selectedModel);
    }
  };

  const handlePromptSelect = (promptText: string) => {
    if (chatPhase === 'READY' && !isStreaming && !isReactTransitionPending) {
      // setInput(promptText); // Optionally set input field
      handleSendMessage(promptText, selectedModel);
    }
  };

  const isRemixNavigating = remixNavigation.state !== 'idle';
  const showPageLoader =
    chatPhase !== 'READY' || isRemixNavigating || isReactTransitionPending;
  const displayInitialPrompts =
    initialChatId === null &&
    messages.length === 0 &&
    !isStreaming &&
    !input &&
    chatPhase === 'READY';
  const showMessageAreaContent =
    chatPhase === 'READY' && !isRemixNavigating && !isReactTransitionPending;
  const childKey = initialChatId || "new-chat-session";


  return (
    <div className="flex flex-col h-full w-full">
      {/* CHAT MESSAGE AREA */}
      <div ref={containerRef} className="flex-grow overflow-y-auto overflow-x-hidden relative">
        {showPageLoader && (
          <div className="absolute inset-0 flex flex-col justify-center items-center bg-background/80 backdrop-blur-sm z-20 p-4 text-center">
            <FourSquare color="hsl(var(--primary))" size="medium" />
            <p className="mt-4 text-sm text-foreground">
              {isRemixNavigating
                ? "Navigating..."
                : isReactTransitionPending
                  ? "Processing..."
                  : chatPhase === 'INITIALIZING'
                    ? "Initializing chat..."
                    : chatPhase === 'PREPARING_CONTENT'
                      ? "Loading messages..."
                      : "Loading..."}
            </p>
          </div>
        )}
        <div
          style={{
            opacity: showMessageAreaContent ? 1 : 0,
            pointerEvents: showMessageAreaContent ? 'auto' : 'none',
            transition: 'opacity 0.2s ease-in-out',
            minHeight: '100%', display: 'flex', flexDirection: 'column',
          }}
          className="w-full" // Ensures this div spans the containerRef width
        >
          {displayInitialPrompts ? (
            <div className="max-w-5xl mx-auto w-full h-full flex flex-col justify-center items-center p-4 flex-grow">
              <InitialPrompts onPromptSelect={handlePromptSelect} />
            </div>
          ) : (
            <div className="max-w-4xl mx-auto w-full flex-grow flex flex-col"> {/* Message content column */}
              <MessageList
                key={`ml-${childKey}`}
                messages={messages}
                isLoading={isStreaming && chatPhase === 'READY'}
                isInitialHistoryLoading={chatPhase === 'PREPARING_CONTENT'}
                scrollEndRef={endRef}
              />
            </div>
          )}
        </div>

        {/* Scroll to bottom button - NEW POSITIONING STRUCTURE */}
        {showScrollDownButton && (
          <div className="sticky bottom-4 w-full flex justify-center pointer-events-none z-30">
            <div className="max-w-4xl w-full flex justify-end pointer-events-auto px-4">
              <button
                onClick={() => scrollToBottom('smooth')}
                className="p-2 bg-card border border-border rounded-full shadow-lg hover:bg-muted focus:outline-none focus-visible:ring-2 focus-visible:ring-primary focus-visible:ring-offset-2 focus-visible:ring-offset-background transition-all duration-150 ease-in-out animate-fade-in"
                aria-label="Scroll to latest messages"
                title="Scroll to latest messages"
                style={{ minWidth: 36, minHeight: 36, width: 36, height: 36 }}
              >
                <FiArrowDown size={16} aria-hidden="true" />
              </button>
            </div>
          </div>
        )}



      </div>

      {/* INPUT BAR */}
      <div className="flex-shrink-0 bg-background border-t border-border">
        <div className="max-w-4xl mx-auto w-full p-2 md:p-3">
          <ChatInputBar
            key={`cib-${childKey}`}
            input={input}
            onInputChange={e => setInput(e.target.value)}
            onSubmit={handleFormSubmit}
            isLoading={
              chatPhase !== 'READY' ||
              isStreaming ||
              isRemixNavigating ||
              isReactTransitionPending
            }
            availableModels={AImodels}
            selectedModel={selectedModel}
            onModelChange={setSelectedModel}
          />
        </div>
      </div>
    </div>
  );
}--- app/components/chat/ChatPageLayout copy.tsx ---
// app/components/ChatPageLayout.tsx (or wherever your ChatPageLayout is)
import { useState, useEffect, useCallback, useRef, useTransition } from 'react';
// If you want Remix's useTransition, use:
// import { useTransition } from '@remix-run/react';
import { useNavigate, useLocation } from '@remix-run/react';
import type { Message } from './MessageItem'; // Adjust path if necessary
import { MessageList } from './MessageList'; // Adjust path if necessary
import { ChatInputBar } from './ChatInputBar'; // Adjust path if necessary
import { InitialPrompts } from './InitialPrompts'; // Adjust path if necessary
import {
  AImodels,
  defaultModelConfig,
  defaultSystemPrompt,
  API_STREAM_URL,
} from '~/lib/ai-models'; // Adjust path if necessary
import type { AIModelConfig } from '~/lib/ai-models'; // Adjust path if necessary

interface ChatPageLayoutProps {
  initialChatId: string | null;
  initialMessages?: Message[];
}

export function ChatPageLayout({ initialChatId, initialMessages = [] }: ChatPageLayoutProps) {
  const navigate = useNavigate();
  const location = useLocation();
  // React 18's useTransition
  const [isPending, startTransition] = useTransition();

  const chatLayoutKey = initialChatId || 'new-chat-session';

  const [messages, setMessages] = useState<Message[]>(initialMessages);
  const [input, setInput] = useState('');
  const [isStreaming, setIsStreaming] = useState(false);
  const [selectedModel, setSelectedModel] = useState<AIModelConfig>(defaultModelConfig);

  const abortControllerRef = useRef<AbortController | null>(null);
  const messagesRef = useRef(messages);

  useEffect(() => {
    messagesRef.current = messages;
  }, [messages]);

  useEffect(() => {
    // Only reset messages if not streaming and initialMessages truly changed for the current chat
    // This avoids resetting messages if initialMessages from loader is stale due to navigation state
    if (!isStreaming && location.state?.fromNewChatFlow !== true) {
      if (JSON.stringify(initialMessages) !== JSON.stringify(messagesRef.current.slice(0, initialMessages.length))) {
        setMessages(initialMessages || []);
      }
    } else if (location.state?.fromNewChatFlow === true) {
      // If navigated from new chat flow, messages are already set via state, clear the flag
      // This assumes navigate state is cleared on subsequent navigations or reloads
      const { state, ...rest } = location;
      // @ts-ignore
      const { fromNewChatFlow, ...newState } = state;
      navigate(rest, { replace: true, state: Object.keys(newState).length > 0 ? newState : undefined });
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [initialMessages, chatLayoutKey]); // Removed isStreaming to allow initialMessages to update if chat ID changes


  useEffect(() => {
    // Abort any ongoing stream and reset state when chat context changes
    if (abortControllerRef.current) {
      abortControllerRef.current.abort("Chat context changed or component unmounting");
      abortControllerRef.current = null;
    }
    setIsStreaming(false); // Ensure streaming is false
    setInput(''); // Clear input

    // Set messages based on initialMessages from loader for the *current* chat ID
    // This effect runs when initialChatId changes, ensuring correct messages are loaded.
    setMessages(initialMessages || []);

    return () => {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort("Component unmounting or initialChatId changing");
        abortControllerRef.current = null;
      }
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [initialChatId]); // Depend only on initialChatId for resetting context

  const handleSendMessage = useCallback(async (inputText: string, modelConfig: AIModelConfig) => {
    if (isStreaming || isPending) return;

    setIsStreaming(true);
    setInput('');

    const newUserMessage: Message = { id: crypto.randomUUID(), role: 'user', content: inputText };
    setMessages(prev => [...prev, newUserMessage]);

    const assistantMessageId = crypto.randomUUID();
    setMessages(prev => [...prev, { id: assistantMessageId, role: 'assistant', content: '' }]);
    const currentAbortController = new AbortController();
    abortControllerRef.current = currentAbortController;
    let chatIdForRequest = initialChatId;

    let receivedChatIdFromStream: string | null = null;

    try {
      const response = await fetch(API_STREAM_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Accept': 'text/event-stream' },
        body: JSON.stringify({
          chatId: chatIdForRequest,
          message: inputText,
          provider: modelConfig.provider,
          model: modelConfig.model,
          systemPrompt: defaultSystemPrompt,
        }),
        signal: currentAbortController.signal,
        credentials: 'include',
      });

      if (currentAbortController.signal.aborted) return;
      if (!response.ok || !response.body) {
        const errorBody = await response.text().catch(() => "Failed to read error body");
        throw new Error(`API Error ${response.status}: ${errorBody.slice(0, 500)}`);
      }

      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = "";

      // eslint-disable-next-line no-constant-condition
      while (true) {
        const { done, value } = await reader.read();
        if (currentAbortController.signal.aborted || done) break;

        buffer += decoder.decode(value, { stream: true });
        let newlineIndex;
        while ((newlineIndex = buffer.indexOf('\n')) >= 0) {
          const line = buffer.slice(0, newlineIndex).trim();
          buffer = buffer.slice(newlineIndex + 1);

          if (line.startsWith("data: ")) {
            const jsonDataString = line.substring(5);
            if (jsonDataString) {
              if (currentAbortController.signal.aborted) break;
              try {
                const chunk = JSON.parse(jsonDataString);
                if (chunk.type === "session_info" && chunk.chatId && !initialChatId) {
                  receivedChatIdFromStream = chunk.chatId;
                }
                handleStreamData(chunk, assistantMessageId);
              } catch (e) {
                if (!currentAbortController.signal.aborted)
                  console.error("Error parsing stream data JSON:", e, jsonDataString);
              }
            }
          }
        }
      }

      if (!initialChatId && receivedChatIdFromStream) {
        // Important: messagesRef.current will have the latest messages *including the streamed response*
        // because setMessages in handleStreamData updates it.
        startTransition(() => {
          navigate(`/chat/${receivedChatIdFromStream}`, {
            replace: true,
            state: { initialMessages: messagesRef.current, fromNewChatFlow: true }
          });
        });
        // setIsStreaming(false) will effectively be handled by the component re-keying or unmounting/remounting
        // due to navigation and change in initialChatId.
      } else {
        // If it's an existing chat or no chatId was received (should not happen for new chat success)
        // ensure streaming state is properly turned off if not already done by stream_end.
        // This check for abort is important here.
        if (!currentAbortController.signal.aborted) {
          setIsStreaming(false);
        }
      }
    } catch (error: any) {
      if (error.name === 'AbortError') {
        // Only update if the message doesn't already indicate abortion
        setMessages(prev =>
          prev.map(msg =>
            msg.id === assistantMessageId && msg.role === 'assistant' && !msg.content.includes("[Stream aborted]")
              ? { ...msg, content: (msg.content || "") + `\n[Stream aborted]` }
              : msg
          ));
      } else {
        console.error(`Send/Stream error:`, error);
        handleStreamError(assistantMessageId, error.message || "Failed to get response.");
      }
    } finally {
      if (abortControllerRef.current === currentAbortController) {
        abortControllerRef.current = null;
      }
      // If the navigation didn't happen (e.g., existing chat) and stream wasn't aborted,
      // ensure streaming is set to false. This is a fallback.
      // However, if navigation happens, the component might unmount/re-key which resets state.
      if (!receivedChatIdFromStream && !currentAbortController.signal.aborted) {
        setIsStreaming(false);
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [initialChatId, isStreaming, selectedModel, navigate, isPending, startTransition]);

  const handleStreamData = (chunk: any, assistantMessageId: string) => {
    // Check if the stream was aborted by a new action or component unmount
    if (abortControllerRef.current?.signal.aborted && !isStreaming) {
      // If isStreaming is false, it means the stream was likely ended or aborted intentionally
      // and we should not process further data for this assistant message.
      return;
    }

    if (chunk.content) {
      setMessages(prev =>
        prev.map(msg =>
          msg.id === assistantMessageId && msg.role === 'assistant'
            ? { ...msg, content: msg.content + chunk.content }
            : msg
        )
      );
    } else if (chunk.type === 'usage_summary' || chunk.type === 'stream_end') {
      // Only set isStreaming to false if the current abort controller is still active
      // or if there's no active abort controller (implying natural end).
      // This prevents race conditions if a new message was sent quickly.
      if (!abortControllerRef.current || !abortControllerRef.current.signal.aborted) {
        setIsStreaming(false);
      }
    } else if (chunk.error) {
      handleStreamError(assistantMessageId, chunk.error.message || chunk.error);
    }
  };

  const handleStreamError = (assistantMessageId: string, errorMessage: string) => {
    setMessages(prev =>
      prev.map(msg =>
        msg.id === assistantMessageId && msg.role === 'assistant' && !msg.content.includes("[Error:")
          ? { ...msg, content: (msg.content || "") + `\n[Error: ${errorMessage}]` }
          : msg
      )
    );
    // Ensure streaming is stopped on error, if not already aborted by a new request
    if (!abortControllerRef.current || !abortControllerRef.current.signal.aborted) {
      setIsStreaming(false);
    }
  };

  const handleFormSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    if (input.trim() && !isStreaming && !isPending) {
      handleSendMessage(input.trim(), selectedModel);
    }
  };

  const handlePromptSelect = (promptText: string) => {
    if (!isStreaming && !isPending) {
      // Set input for immediate display, then send
      setInput(promptText);
      handleSendMessage(promptText, selectedModel);
    }
  };

  const isNavigating = isPending; // useTransition's pending state
  const displayInitialPrompts =
    initialChatId === null &&
    messages.length === 0 &&
    !isStreaming &&
    !input &&
    !isNavigating;

  // Use initialChatId for keying child components that depend on chat context
  const childKey = initialChatId || "new-chat-internal";

  return (
    // Root div: takes full height and width from parent (AppLayout's main area)
    // flex flex-col ensures children (message area and input bar) are stacked vertically
    <div className="flex flex-col h-full w-full">

      {/* Message List Area:
          - flex-grow: takes up all available vertical space after input bar is accounted for.
          - overflow-y-auto: enables vertical scrolling ONLY for this area.
          - The scrollbar will appear on the right edge of THIS div.
      */}
      <div className="flex-grow overflow-y-auto">
        {displayInitialPrompts ? (
          // Container for InitialPrompts, centered within the scrollable area
          // max-w-4xl mx-auto ensures content is centered horizontally
          // h-full allows vertical centering content using flex
          // p-4 for padding
          <div className="max-w-4xl mx-auto w-full h-full flex flex-col justify-center items-center p-4">
            <InitialPrompts onPromptSelect={handlePromptSelect} />
          </div>
        ) : (
          // Container for MessageList
          // max-w-4xl mx-auto ensures messages are centered horizontally
          // w-full ensures it uses the available width up to max-w-4xl
          // p-4 provides padding around the message list. Consider pb-0 if MessageList handles last item spacing.
          <div className="max-w-4xl mx-auto w-full p-4">
            <MessageList
              key={`ml-${childKey}`} // Keyed to re-render if chat changes
              messages={messages}
              isLoading={isStreaming && !isNavigating} // Show loading indicator if streaming and not navigating away
            />
          </div>
        )}
      </div>

      {/* Chat Input Bar Area:
          - flex-shrink-0: prevents this area from shrinking.
          - bg-background, border-t, border-border: styling.
      */}
      <div className="flex-shrink-0 bg-background border-t border-border">
        {/* Content wrapper for ChatInputBar:
            - max-w-4xl mx-auto: centers the input bar content.
            - w-full: ensures it takes full width up to max-w-4xl.
            - p-2 md:p-3: original padding.
        */}
        <div className="max-w-4xl mx-auto w-full p-2 md:p-3">
          <ChatInputBar
            key={`cib-${childKey}`} // Keyed to re-render if chat changes
            input={input}
            onInputChange={e => setInput(e.target.value)}
            onSubmit={handleFormSubmit}
            isLoading={isStreaming || isNavigating} // Input disabled if streaming or navigating
            availableModels={AImodels}
            selectedModel={selectedModel}
            onModelChange={setSelectedModel}
          />
        </div>
      </div>
    </div>
  );
}--- app/components/sidebar-header.tsx ---
// components/sidebar-header.tsx  
"use client";  
import * as React from "react";  
import { Plus, type LucideIcon } from "lucide-react";  
import { Button } from "~/components/ui/button";  
import { cn } from "~/lib/utils";  
import { Link } from "@remix-run/react"; // For app logo link
  
interface SidebarHeaderProps extends React.HTMLAttributes<HTMLDivElement> {  
  appName: string;  
  appIcon: LucideIcon;  
  onNewChat?: () => void;  
}  
  
export function SidebarHeader({  
  className,  
  appName,  
  appIcon: AppIcon,  
  onNewChat,  
}: SidebarHeaderProps) {  
  return (  
    <div className={cn("flex flex-col gap-4 p-4", className)}>  
      <Link to="/" prefetch="intent" className="flex items-center gap-3 focus:outline-none group">  
        <span className="flex aspect-square size-9 items-center justify-center rounded-lg bg-sidebar-primary text-sidebar-primary-foreground transition-colors group-hover:bg-sidebar-primary/90 group-focus-visible:ring-2 group-focus-visible:ring-ring group-focus-visible:ring-offset-2  group-focus-visible:ring-offset-sidebar">  
          <AppIcon className="size-5" />  
        </span>  
        <span className="font-semibold text-xl tracking-tight text-sidebar-foreground transition-colors group-hover:text-sidebar-foreground/80">  
          {appName}  
        </span>  
      </Link>  
      <Button  
        variant="default" // Ensure this variant uses sidebar-primary colors or adjust
        size="sm"  
        className={cn(  
          "w-full flex items-center justify-start gap-2 py-1.5 px-1", // Reduced padding slightly for "New Chat" for better look if text is short
          "text-sm font-medium rounded-md transition-colors",  
          // Assuming 'default' variant is styled appropriately for primary action in sidebar
          // If not, explicitly set: "bg-sidebar-primary text-sidebar-primary-foreground hover:bg-sidebar-primary/90",
          "focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sidebar-ring focus-visible:ring-offset-2 focus-visible:ring-offset-sidebar"  
        )}  
        onClick={onNewChat}  
      >  
        <Plus className="size-4" />  
        <span>New Chat</span>  
      </Button>  
    </div>  
  );  
}--- app/components/app-sidebar.tsx ---
// components/app-sidebar.tsx
"use client";

import * as React from "react";
import { SidebarHeader as CustomSidebarHeader } from "./sidebar-header";
import { SidebarAccount } from "./sidebar-account";
import { SidebarNav, type NavItem } from "./sidebar-nav"; // Import NavItem
import {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarHeader,
} from "~/components/ui/sidebar";
import { cn } from "~/lib/utils";
import { Command } from "lucide-react"; // Default app icon
import { getApiUrl } from "~/lib/api.config"; // For logout
import { useNavigate } from "@remix-run/react"; // For navigation

// Define the props AppSidebar expects
interface AppSidebarComponentProps {
  user: {
    name: string;
    email: string;
    avatar: string;
  };
  appName: string;
  mainNav: NavItem[]; // Using NavItem type from sidebar-nav
  // Add other props that might be passed to the underlying Sidebar primitive
}

// Combine with the Sidebar primitive's props, excluding ones we manage
type AppSidebarProps = AppSidebarComponentProps & Omit<React.ComponentProps<typeof Sidebar>, keyof AppSidebarComponentProps>;


export function AppSidebar({
  user,
  appName,
  mainNav,
  className, // from React.ComponentProps<typeof Sidebar>
  ...props // other props for Sidebar primitive
}: AppSidebarProps) {
  const navigate = useNavigate();

  const handleNewChat = () => {
    console.log("New Chat clicked");
    // Implement your new chat logic here, e.g., navigate to a new chat route
    // navigate("/chat/new"); // Example
  };

  const handleLogout = async () => {
    // Navigate to the backend logout endpoint.
    // The backend should handle clearing HttpOnly cookies and invalidating the session.
    // After the backend logout, it should redirect the user, perhaps to the login page.
    try {
        const logoutUrl = getApiUrl("AUTH_LOGOUT");
        // We expect the backend to handle the redirect after logout.
        // If it just returns a success/failure, then navigate client-side.
        window.location.href = logoutUrl; // Simplest way to ensure cookies are handled by browser redirect
    } catch (error) {
        console.error("Failed to get logout URL:", error);
        // Fallback or error handling
        navigate("/login?error=logout_failed");
    }
  };


  return (
    <Sidebar
      {...props} // Pass through other props to the Sidebar primitive
      className={cn(
        "bg-sidebar text-sidebar-foreground border-r border-sidebar-border",
        className // Allow overriding classes
      )}
    >
      <SidebarHeader className="p-0">
        <CustomSidebarHeader
          appName={appName}
          appIcon={Command} // You can make appIcon a prop too if it varies
          onNewChat={handleNewChat}
        />
      </SidebarHeader>

      <SidebarContent className="flex-1 overflow-y-auto p-0">
        <SidebarNav mainNav={mainNav} />
      </SidebarContent>

      <SidebarFooter className="p-0 mt-auto border-t border-sidebar-border">
        <SidebarAccount user={user} onLogout={handleLogout} />
      </SidebarFooter>
    </Sidebar>
  );
}--- app/entry.server.tsx ---
/**
 * By default, Remix will handle generating the HTTP Response for you.
 * You are free to delete this file if you'd like to, but if you ever want it revealed again, you can run `npx remix reveal` ✨
 * For more information, see https://remix.run/file-conventions/entry.server
 */

import { PassThrough } from "node:stream";

import type { AppLoadContext, EntryContext } from "@remix-run/node";
import { createReadableStreamFromReadable } from "@remix-run/node";
import { RemixServer } from "@remix-run/react";
import { isbot } from "isbot";
import { renderToPipeableStream } from "react-dom/server";

const ABORT_DELAY = 5_000;

export default function handleRequest(
  request: Request,
  responseStatusCode: number,
  responseHeaders: Headers,
  remixContext: EntryContext,
  // This is ignored so we can keep it in the template for visibility.  Feel
  // free to delete this parameter in your app if you're not using it!
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  loadContext: AppLoadContext
) {
  return isbot(request.headers.get("user-agent") || "")
    ? handleBotRequest(
        request,
        responseStatusCode,
        responseHeaders,
        remixContext
      )
    : handleBrowserRequest(
        request,
        responseStatusCode,
        responseHeaders,
        remixContext
      );
}

function handleBotRequest(
  request: Request,
  responseStatusCode: number,
  responseHeaders: Headers,
  remixContext: EntryContext
) {
  return new Promise((resolve, reject) => {
    let shellRendered = false;
    const { pipe, abort } = renderToPipeableStream(
      <RemixServer
        context={remixContext}
        url={request.url}
        abortDelay={ABORT_DELAY}
      />,
      {
        onAllReady() {
          shellRendered = true;
          const body = new PassThrough();
          const stream = createReadableStreamFromReadable(body);

          responseHeaders.set("Content-Type", "text/html");

          resolve(
            new Response(stream, {
              headers: responseHeaders,
              status: responseStatusCode,
            })
          );

          pipe(body);
        },
        onShellError(error: unknown) {
          reject(error);
        },
        onError(error: unknown) {
          responseStatusCode = 500;
          // Log streaming rendering errors from inside the shell.  Don't log
          // errors encountered during initial shell rendering since they'll
          // reject and get logged in handleDocumentRequest.
          if (shellRendered) {
            console.error(error);
          }
        },
      }
    );

    setTimeout(abort, ABORT_DELAY);
  });
}

function handleBrowserRequest(
  request: Request,
  responseStatusCode: number,
  responseHeaders: Headers,
  remixContext: EntryContext
) {
  return new Promise((resolve, reject) => {
    let shellRendered = false;
    const { pipe, abort } = renderToPipeableStream(
      <RemixServer
        context={remixContext}
        url={request.url}
        abortDelay={ABORT_DELAY}
      />,
      {
        onShellReady() {
          shellRendered = true;
          const body = new PassThrough();
          const stream = createReadableStreamFromReadable(body);

          responseHeaders.set("Content-Type", "text/html");

          resolve(
            new Response(stream, {
              headers: responseHeaders,
              status: responseStatusCode,
            })
          );

          pipe(body);
        },
        onShellError(error: unknown) {
          reject(error);
        },
        onError(error: unknown) {
          responseStatusCode = 500;
          // Log streaming rendering errors from inside the shell.  Don't log
          // errors encountered during initial shell rendering since they'll
          // reject and get logged in handleDocumentRequest.
          if (shellRendered) {
            console.error(error);
          }
        },
      }
    );

    setTimeout(abort, ABORT_DELAY);
  });
}
